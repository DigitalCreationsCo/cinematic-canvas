diff --git a/.env.example b/.env.example
index dc7df23..38e0261 100644
--- a/.env.example
+++ b/.env.example
@@ -2,6 +2,7 @@
 GCP_PROJECT_ID="your-gcp-project-id"
 GCP_BUCKET_NAME="your-gcp-bucket-name"
 GCP_REGION="us-east1"
+GCP_LOCATION="global"
 GOOGLE_APPLICATION_CREDENTIALS="/path/to/your/credentials.json"
 PUBSUB_EMULATOR_HOST=""
 
diff --git a/.gitignore b/.gitignore
index 9565b80..abf8574 100644
--- a/.gitignore
+++ b/.gitignore
@@ -6,8 +6,15 @@ vite.config.ts.*
 tsconfig.tsbuildinfo
 latest_attempts.json
 audio
-.keeper
+
+# Local test files
+/tmp/
+test_videos/
+*.mp4
+*.avi
+**/coverage/
 diff
+script/vertex-ai/out/*.json
 
 # Terraform
 .terraform/
@@ -48,6 +55,7 @@ wheels/
 *.swp
 *.swo
 *~
+.keeper
 
 # OS
 .DS_Store
@@ -55,10 +63,3 @@ Thumbs.db
 
 # Logs
 *.log
-
-# Local test files
-/tmp/
-test_videos/
-*.mp4
-*.avi
-**/coverage/
\ No newline at end of file
diff --git a/docs/IMPLEMENTATION_SUMMARY.md b/docs/IMPLEMENTATION_SUMMARY.md
index c4c110a..f0f6417 100644
--- a/docs/IMPLEMENTATION_SUMMARY.md
+++ b/docs/IMPLEMENTATION_SUMMARY.md
@@ -103,7 +103,7 @@ The project now includes the following new/modified files/directories:
 
 ## 6. UI/UX Enhancements (Current Release)
 
- **Real-Time Progress Tracking**: The system now sends `SCENE_PROGRESS` events, allowing the frontend to display granular progress messages (e.g., "Generating start frame image...") on the Scene Cards and the Scene Detail Panel while a scene is generating.
+ **Real-Time Progress Tracking**: The system now sends `SCENE_UPDATE` events, allowing the frontend to display granular progress messages (e.g., "Generating start frame image...") on the Scene Cards and the Scene Detail Panel while a scene is generating.
 
  **Character Card Redesign**: The Character Card component (`client/src/components/CharacterCard.tsx`) has been redesigned to emphasize the character's reference image in a vertical (3:4) aspect ratio, moving metadata and description to a dense footer for better visual reference in the Character gallery.
 
diff --git a/docs/PUBSUB_ARCHITECTURE.md b/docs/PUBSUB_ARCHITECTURE.md
index ebe8de4..956ffeb 100644
--- a/docs/PUBSUB_ARCHITECTURE.md
+++ b/docs/PUBSUB_ARCHITECTURE.md
@@ -21,7 +21,7 @@ In the refactored architecture, Google Cloud Pub/Sub operates as the asynchronou
 *   **Cancellation**: For stopping operations, a dedicated `pipeline-cancellations` topic broadcasts to all workers (Fan-Out) so the specific worker handling that project can abort immediately.
 
 ### C. Frontend Updates (Real-time Status)
-*   **Events**: As work progresses, both **Pipeline** and **Worker** publish status updates (e.g., `SCENE_PROGRESS`) to the `pipeline-events` topic.
+*   **Events**: As work progresses, both **Pipeline** and **Worker** publish status updates (e.g., `SCENE_UPDATE`) to the `pipeline-events` topic.
 *   **Forwarding**: The **Server** listens via the [`server-pipeline-events-subscription`](../src/shared/constants.ts) and forwards these events to the browser via Server-Sent Events (SSE).
 
 ## Architecture Diagram
diff --git a/docs/WORKFLOW_INTEGRATION.md b/docs/WORKFLOW_INTEGRATION.md
index 14a9941..a4a2907 100644
--- a/docs/WORKFLOW_INTEGRATION.md
+++ b/docs/WORKFLOW_INTEGRATION.md
@@ -74,14 +74,14 @@ const systemPrompt = composeStoryboardEnrichmentPrompt(
 
 #### Character Reference Images
 - **Function:** `generateCharacterAssets()`
-- **New Feature:** Now accepts an optional `onProgress` callback to provide real-time status updates (via `SCENE_PROGRESS` events) for scenes related to the character being generated.
+- **New Feature:** Now accepts an optional `onProgress` callback to provide real-time status updates (via `SCENE_UPDATE` events) for scenes related to the character being generated.
 - **Role Prompt Used:** `buildCostumeAndMakeupPrompt()` via wrapper [pipeline/prompts/character-image-instruction.ts](pipeline/prompts/character-image-instruction.ts)
 - **Department:** Costume & Makeup
 - **Output:** Reference images for each character
 
 #### Location Reference Images
 - **Function:** `generateLocationAssets()`
-- **New Feature:** Now accepts an optional `onProgress` callback to provide real-time status updates (via `SCENE_PROGRESS` events) for scenes related to the location being generated.
+- **New Feature:** Now accepts an optional `onProgress` callback to provide real-time status updates (via `SCENE_UPDATE` events) for scenes related to the location being generated.
 - **Role Prompt Used:** `buildProductionDesignerPrompt()` via wrapper [pipeline/prompts/location-image-instruction.ts](pipeline/prompts/location-image-instruction.ts)
 - **Department:** Production Design
 - **Output:** Reference images for each location
diff --git a/docs/architecture/transient_workflow_state.md b/docs/architecture/transient_workflow_state.md
index 79e84f3..d368661 100644
--- a/docs/architecture/transient_workflow_state.md
+++ b/docs/architecture/transient_workflow_state.md
@@ -378,7 +378,7 @@ async function onUpdateAssetCommand(msg: UpdateSceneAssetCommand) {
     
     // Broadcast back to Client
     pubsub.publish(`project:${msg.projectId}`, {
-      type: "SCENE_PROGRESS",
+      type: "SCENE_UPDATE",
       projectId: msg.projectId,
       timestamp: new Date().toISOString(),
       payload: {
diff --git a/docs/architecture/workflow-system.md b/docs/architecture/workflow-system.md
index f3c5cb0..716b555 100644
--- a/docs/architecture/workflow-system.md
+++ b/docs/architecture/workflow-system.md
@@ -97,14 +97,14 @@ const systemPrompt = composeStoryboardEnrichmentPrompt(
 
 #### Character Reference Images
 - **Function:** `generateCharacterAssets()`
-- **New Feature:** Now accepts an optional `onProgress` callback to provide real-time status updates (via `SCENE_PROGRESS` events) for scenes related to the character being generated.
+- **New Feature:** Now accepts an optional `onProgress` callback to provide real-time status updates (via `SCENE_UPDATE` events) for scenes related to the character being generated.
 - **Role Prompt Used:** `buildCostumeAndMakeupPrompt()` via wrapper [pipeline/prompts/character-image-instruction.ts](pipeline/prompts/character-image-instruction.ts)
 - **Department:** Costume & Makeup
 - **Output:** Reference images for each character
 
 #### Location Reference Images
 - **Function:** `generateLocationAssets()`
-- **New Feature:** Now accepts an optional `onProgress` callback to provide real-time status updates (via `SCENE_PROGRESS` events) for scenes related to the location being generated.
+- **New Feature:** Now accepts an optional `onProgress` callback to provide real-time status updates (via `SCENE_UPDATE` events) for scenes related to the location being generated.
 - **Role Prompt Used:** `buildProductionDesignerPrompt()` via wrapper [pipeline/prompts/location-image-instruction.ts](pipeline/prompts/location-image-instruction.ts)
 - **Department:** Production Design
 - **Output:** Reference images for each location
diff --git a/docs/graph_diagram.png b/docs/graph_diagram.png
new file mode 100644
index 0000000..d09a9c3
Binary files /dev/null and b/docs/graph_diagram.png differ
diff --git a/docs/graph_diagram_01172026330.png b/docs/graph_diagram_01172026330.png
new file mode 100644
index 0000000..4f93b0f
Binary files /dev/null and b/docs/graph_diagram_01172026330.png differ
diff --git a/docs/graph_structure.mmd b/docs/graph_structure.mmd
new file mode 100644
index 0000000..f78480f
--- /dev/null
+++ b/docs/graph_structure.mmd
@@ -0,0 +1,62 @@
+%%{init: {'flowchart': {'curve': 'linear'}}}%%
+graph TD;
+	__start__([<p>__start__</p>]):::first
+	expand_creative_prompt(expand_creative_prompt)
+	generate_storyboard_exclusively_from_prompt(generate_storyboard_exclusively_from_prompt)
+	create_scenes_from_audio(create_scenes_from_audio)
+	enrich_storyboard_and_scenes(enrich_storyboard_and_scenes)
+	semantic_analysis(semantic_analysis)
+	generate_character_assets(generate_character_assets)
+	generate_location_assets(generate_location_assets)
+	generate_scene_assets(generate_scene_assets)
+	process_scene(process_scene)
+	render_video(render_video)
+	finalize(finalize)
+	__end__([<p>__end__</p>]):::last
+	create_scenes_from_audio --> enrich_storyboard_and_scenes;
+	enrich_storyboard_and_scenes --> semantic_analysis;
+	finalize --> __end__;
+	generate_character_assets --> generate_location_assets;
+	generate_location_assets --> generate_scene_assets;
+	generate_scene_assets --> process_scene;
+	generate_storyboard_exclusively_from_prompt --> enrich_storyboard_and_scenes;
+	render_video --> finalize;
+	semantic_analysis --> generate_character_assets;
+	__start__ -.-> expand_creative_prompt;
+	__start__ -.-> generate_storyboard_exclusively_from_prompt;
+	__start__ -.-> create_scenes_from_audio;
+	__start__ -.-> enrich_storyboard_and_scenes;
+	__start__ -.-> semantic_analysis;
+	__start__ -.-> generate_character_assets;
+	__start__ -.-> generate_location_assets;
+	__start__ -.-> generate_scene_assets;
+	__start__ -.-> process_scene;
+	__start__ -.-> render_video;
+	__start__ -.-> finalize;
+	__start__ -.-> __end__;
+	process_scene -.-> expand_creative_prompt;
+	process_scene -.-> generate_storyboard_exclusively_from_prompt;
+	process_scene -.-> create_scenes_from_audio;
+	process_scene -.-> enrich_storyboard_and_scenes;
+	process_scene -.-> semantic_analysis;
+	process_scene -.-> generate_character_assets;
+	process_scene -.-> generate_location_assets;
+	process_scene -.-> generate_scene_assets;
+	process_scene -.-> render_video;
+	process_scene -.-> finalize;
+	process_scene -.-> __end__;
+	expand_creative_prompt -.-> create_scenes_from_audio;
+	expand_creative_prompt -.-> generate_storyboard_exclusively_from_prompt;
+	generate_storyboard_exclusively_from_prompt -.-> enrich_storyboard_and_scenes;
+	create_scenes_from_audio -.-> enrich_storyboard_and_scenes;
+	enrich_storyboard_and_scenes -.-> semantic_analysis;
+	semantic_analysis -.-> generate_character_assets;
+	generate_character_assets -.-> generate_location_assets;
+	generate_location_assets -.-> generate_scene_assets;
+	generate_scene_assets -.-> process_scene;
+	process_scene -.-> render_video;
+	render_video -.-> finalize;
+	process_scene -.-> process_scene;
+	classDef default fill:#f2f0ff,line-height:1.2;
+	classDef first fill-opacity:0;
+	classDef last fill:#bfb6fc;
diff --git a/script/vertex-ai/test-json-schema-request.ts b/script/vertex-ai/test-json-schema-request.ts
new file mode 100644
index 0000000..58ebc80
--- /dev/null
+++ b/script/vertex-ai/test-json-schema-request.ts
@@ -0,0 +1,98 @@
+import { execSync } from 'child_process';
+import { getJsonSchema, InitialContextSchema, Scene } from '../../src/shared/types/workflow.types';
+import { buildDirectorVisionPrompt } from "../../src/workflow/prompts/role-director";
+import fs from 'fs';
+
+async function callVertexAI() {
+    try {
+        // 2. Get Access Token via CLI
+        const accessToken = execSync('gcloud auth print-access-token', {
+            // stdio: [stdin, stdout, stderr]
+            // 'pipe' for stdout tells Node to capture it
+            // 'ignore' for stderr tells Node to throw away the Python warnings
+            stdio: [ 'ignore', 'pipe', 'ignore' ]
+        }).toString().trim();
+
+        // 3. Prepare configuration
+        const project = process.env.GCP_PROJECT_ID;
+        const location = process.env.GCP_LOCATION;
+        const modelId = process.env.TEXT_MODEL_NAME;
+        const endpoint = `https://aiplatform.googleapis.com/v1/projects/${project}/locations/global/publishers/google/models/${modelId}:generateContent`;
+
+        const jsonSchema = getJsonSchema(InitialContextSchema);
+
+        const jsonPath = 'script/vertex-ai/out/json-schema.json'
+        fs.writeFileSync(jsonPath, JSON.stringify(jsonSchema, null, 2), 'utf-8');
+        console.log(`Schema saved successfully to ${jsonPath}`);
+
+        const title = "My Storyboard";
+        const enhancedPrompt = "My Enhanced Prompt";
+        const scenes:Scene[] = [];
+        const totalDuration = 0;
+        const systemPrompt = buildDirectorVisionPrompt(title, enhancedPrompt, JSON.stringify(jsonSchema), scenes, totalDuration);
+        
+            const context = `
+              Generate the initial storyboard context including:
+        
+              ### Metadata
+              ${JSON.stringify(getJsonSchema(InitialContextSchema.shape.metadata))}
+        
+              ### Characters
+              ${JSON.stringify(getJsonSchema(InitialContextSchema.shape.characters))}
+        
+              ### Locations
+              ${JSON.stringify(getJsonSchema(InitialContextSchema.shape.locations))}
+        
+              The scene-by-scene breakdown will be handled in a second pass.
+            `;
+        
+        // 4. Construct the Payload
+        const payload = {
+            contents: [
+                { role: 'user', parts: [ { text: systemPrompt } ] },
+                { role: 'user', parts: [ { text: context } ] }
+            ],
+            generationConfig: {
+                responseMimeType: "application/json",
+                responseJsonSchema: jsonSchema,
+                thinkingConfig: {
+                    thinkingLevel: "HIGH"
+                }
+            }
+        };
+
+        // 5. Simple HTTP Request (using native fetch)
+        const response = await fetch(endpoint, {
+            method: 'POST',
+            headers: {
+                'Authorization': `Bearer ${accessToken}`,
+                'Content-Type': 'application/json',
+            },
+            body: JSON.stringify(payload)
+        });
+
+        if (!response.ok) {
+            const errorText = await response.text();
+            throw new Error(`Vertex AI API Error: ${response.status} - ${errorText}`);
+        }
+
+        const result = await response.json();
+
+        const resultPath = 'script/vertex-ai/out/result.json'
+        fs.writeFileSync(resultPath, JSON.stringify(result, null, 2), 'utf-8');
+        console.log(`Response saved successfully to ${resultPath}`);
+        
+        const content = result.candidates[0].content.parts[0].text;
+        const parsedContent = JSON.parse(content);
+        
+        const contentPath = 'script/vertex-ai/out/content.json'
+        fs.writeFileSync(contentPath, JSON.stringify(parsedContent, null, 2), 'utf-8');
+        console.log(`Content saved successfully to ${contentPath}`);
+        
+
+    } catch (error) {
+        console.error("Execution failed:", error);
+    }
+}
+
+callVertexAI();
\ No newline at end of file
diff --git a/src/client/src/components/AssetHistoryPicker.tsx b/src/client/src/components/AssetHistoryPicker.tsx
index 11e0785..7178fe0 100644
--- a/src/client/src/components/AssetHistoryPicker.tsx
+++ b/src/client/src/components/AssetHistoryPicker.tsx
@@ -135,7 +135,7 @@ export function AssetHistoryPicker({
                                                 <div className="p-2 text-xs text-muted-foreground bg-card">
                                                     <div className="flex items-center gap-1">
                                                         <Clock className="w-3 h-3" />
-                                                        <span>{ formatTime(asset.createdAt) }</span>
+                                                        <span>{ formatTime(asset.createdAt.toISOString()) }</span>  
                                                     </div>
                                                 </div>
                                             </div>
diff --git a/src/client/src/components/ProjectSelectionModal.tsx b/src/client/src/components/ProjectSelectionModal.tsx
index 438d888..9f5a453 100644
--- a/src/client/src/components/ProjectSelectionModal.tsx
+++ b/src/client/src/components/ProjectSelectionModal.tsx
@@ -6,8 +6,9 @@ import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
 import { Input } from "@/components/ui/input";
 import { Label } from "@/components/ui/label";
 import { Textarea } from "@/components/ui/textarea";
+import { Card, CardContent } from "@/components/ui/card";
 import { uploadAudio, startPipeline } from "@/lib/api";
-import { Loader2 } from "lucide-react";
+import { Loader2, Moon, Sun, Sparkles, FolderOpen, Plus } from "lucide-react";
 import { useStore } from '@/lib/store';
 import { Project } from '@shared/types/workflow.types';
 
@@ -27,7 +28,7 @@ export const ProjectSelectionModal: React.FC<ProjectSelectionModalProps> = ({
   onConfirm,
 }) => {
 
-  const { setProjectStatus, setProject } = useStore();
+  const { setProjectStatus, setProject, isDark } = useStore();
 
   const [ mode, setMode ] = useState<"resume" | "create">("resume");
   const [ title, setTitle ] = useState("");
@@ -62,7 +63,6 @@ export const ProjectSelectionModal: React.FC<ProjectSelectionModalProps> = ({
         },
       });
 
-      // Optimistic update to show "Analyzing" state immediately
       setProject({
         currentSceneIndex: 0,
         generationRules: [],
@@ -96,87 +96,126 @@ export const ProjectSelectionModal: React.FC<ProjectSelectionModalProps> = ({
 
   return (
     <Dialog open={ isOpen }>
-      <DialogContent className="sm:max-w-[500px]">
-        <DialogHeader>
-          <DialogTitle>Select or Create Project</DialogTitle>
-          <DialogDescription>
-            Resume an existing project or start a new cinematic video generation.
-          </DialogDescription>
+      <DialogContent className="sm:max-w-[500px] p-0 flex flex-col gap-0 overflow-hidden">
+        <DialogHeader className="p-4 border-b flex flex-row items-center justify-between gap-4 shrink-0 space-y-0">
+          <div className="flex flex-col gap-1 min-w-0">
+            <DialogTitle className="text-lg font-semibold truncate">Select or Create Project</DialogTitle>
+            <DialogDescription className="text-xs text-muted-foreground truncate">
+              Resume an existing project or start a new cinematic video generation.
+            </DialogDescription>
+          </div>
         </DialogHeader>
 
-        <Tabs defaultValue="resume" value={ mode } onValueChange={ (v) => setMode(v as any) } className="w-full">
-          <TabsList className="grid w-full grid-cols-2">
-            <TabsTrigger value="resume">Resume Existing</TabsTrigger>
-            <TabsTrigger value="create">Start New</TabsTrigger>
-          </TabsList>
-
-          <TabsContent value="resume" className="space-y-4 py-4">
-            <div className="grid gap-2">
-              <Label>Select Project</Label>
-              <Select onValueChange={ onSelectProject } value={ selectedProject }>
-                <SelectTrigger className="w-full">
-                  <SelectValue placeholder="Select a project" />
-                </SelectTrigger>
-                <SelectContent>
-                  { projects.map((project) => (
-                    <SelectItem key={ project.id } value={ project.id }>
-                      { project.metadata.title }
-                    </SelectItem>
-                  )) }
-                </SelectContent>
-              </Select>
-            </div>
-            <Button onClick={ () => onConfirm() } disabled={ !selectedProject } className="w-full">
-              Load Project
-            </Button>
-          </TabsContent>
-
-          <TabsContent value="create" className="space-y-4 py-4">
-            <div className="grid gap-2">
-              <Label htmlFor="projectId">Project Name (optional)</Label>
-              <Input
-                id="title"
-                value={ title }
-                onChange={ (e) => setTitle(e.target.value) }
-                placeholder="This Is Your Moment"
-              />
-            </div>
-
-            <div className="grid gap-2">
-              <Label htmlFor="prompt">Creative Prompt</Label>
-              <Textarea
-                id="prompt"
-                value={ enhancedPrompt }
-                onChange={ (e) => setCreativePrompt(e.target.value) }
-                placeholder="Describe the cinematic video you want to generate..."
-                className="h-24"
-              />
-            </div>
-
-            <div className="grid gap-2">
-              <Label htmlFor="audio">Audio Track</Label>
-              <Input
-                id="audio"
-                type="file"
-                accept="audio/*"
-                onChange={ (e) => setAudioFile(e.target.files?.[ 0 ] || null) }
-              />
+        <div className="flex-1 overflow-y-auto">
+          <Tabs defaultValue="resume" value={ mode } onValueChange={ (v) => setMode(v as any) } className="w-full flex flex-col">
+            <div className="px-4 pt-3 shrink-0">
+              <TabsList className="w-full grid grid-cols-2">
+                <TabsTrigger value="resume" data-testid="tab-resume">
+                  <FolderOpen className="w-4 h-4 mr-1.5" />
+                  Resume Existing
+                </TabsTrigger>
+                <TabsTrigger value="create" data-testid="tab-create">
+                  <Plus className="w-4 h-4 mr-1.5" />
+                  Start New
+                </TabsTrigger>
+              </TabsList>
             </div>
 
-            { error && <div className="text-sm text-red-500">{ error }</div> }
-
-            <Button onClick={ handleCreateProject } disabled={ isCreating } className="w-full">
-              { isCreating ? (
-                <>
-                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
-                  Creating...
-                </>
-              ) : (
-                "Create & Start Project"
-              ) }
-            </Button>
-          </TabsContent>
-        </Tabs>
+            <TabsContent value="resume" className="flex-1 p-4 mt-0">
+              <Card className="border-none shadow-none bg-transparent">
+                <CardContent className="p-0 space-y-4">
+                  <div className="grid gap-2">
+                    <Label className="text-sm font-medium">Select Project</Label>
+                    <Select onValueChange={ onSelectProject } value={ selectedProject }>
+                      <SelectTrigger className="w-full">
+                        <SelectValue placeholder="Select a project" />
+                      </SelectTrigger>
+                      <SelectContent>
+                        { projects.length > 0 ? projects.map((project) => (
+                          <SelectItem key={ project.id } value={ project.id }>
+                            { project.metadata.title || "Untitled Project" }
+                            <span className="ml-2 text-[10px] text-muted-foreground font-mono opacity-50">#{ project.id.slice(0, 8) }</span>
+                          </SelectItem>
+                        )) : (
+                          <div className="p-4 text-center text-sm text-muted-foreground">
+                            No projects found.
+                          </div>
+                        ) }
+                      </SelectContent>
+                    </Select>
+                  </div>
+                  <Button
+                    onClick={ () => onConfirm() }
+                    disabled={ !selectedProject }
+                    className="w-full"
+                  >
+                    Load Project
+                  </Button>
+                </CardContent>
+              </Card>
+            </TabsContent>
+
+            <TabsContent value="create" className="flex-1 p-4 mt-0">
+              <Card className="border-none shadow-none bg-transparent">
+                <CardContent className="p-0 space-y-4">
+                  <div className="grid gap-2">
+                    <Label htmlFor="title" className="text-sm font-medium">Project Name (optional)</Label>
+                    <Input
+                      id="title"
+                      value={ title }
+                      onChange={ (e) => setTitle(e.target.value) }
+                      placeholder="e.g., This Is My Moment"
+                    />
+                  </div>
+
+                  <div className="grid gap-2">
+                    <Label htmlFor="prompt" className="text-sm font-medium">Creative Prompt</Label>
+                    <Textarea
+                      id="prompt"
+                      value={ enhancedPrompt }
+                      onChange={ (e) => setCreativePrompt(e.target.value) }
+                      placeholder="Describe the cinematic video you want to generate..."
+                      className="h-24"
+                    />
+                  </div>
+
+                  <div className="grid gap-2">
+                    <Label htmlFor="audio" className="text-sm font-medium">
+                      Audio (optional)
+                    </Label>
+                    <Input
+                      id="audio"
+                      type="file"
+                      accept="audio/*"
+                      onChange={ (e) => setAudioFile(e.target.files?.[ 0 ] || null) }
+                      className="cursor-pointer"
+                    />
+                  </div>
+
+                  { error && <div className="text-sm text-destructive bg-destructive/10 p-2 rounded-md border border-destructive/20">{ error }</div> }
+
+                  <Button
+                    onClick={ handleCreateProject }
+                    disabled={ isCreating }
+                    className="w-full"
+                  >
+                    { isCreating ? (
+                      <>
+                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
+                        Creating...
+                      </>
+                    ) : (
+                      <>
+                        <Sparkles className="mr-2 h-4 w-4" />
+                        Create & Start Project
+                      </>
+                    ) }
+                  </Button>
+                </CardContent>
+              </Card>
+            </TabsContent>
+          </Tabs>
+        </div>
       </DialogContent>
     </Dialog>
   );
diff --git a/src/client/src/components/QualityEvaluationPanel.tsx b/src/client/src/components/QualityEvaluationPanel.tsx
index 6029429..5738eb6 100644
--- a/src/client/src/components/QualityEvaluationPanel.tsx
+++ b/src/client/src/components/QualityEvaluationPanel.tsx
@@ -65,7 +65,7 @@ export default function QualityEvaluationPanel({ evaluation, sceneId }: QualityE
       <CardHeader className="p-3 pb-2">
         <div className="flex items-center justify-between gap-2">
           <CardTitle className="text-sm font-semibold">Quality Evaluation</CardTitle>
-          <StatusBadge status={ evaluation.overall } />
+          <StatusBadge status={ evaluation.grade } />
         </div>
       </CardHeader>
       <CardContent className="p-3 pt-0 space-y-4">
diff --git a/src/client/src/hooks/use-pipeline-events.ts b/src/client/src/hooks/use-pipeline-events.ts
index 2b9b3e9..32c3194 100644
--- a/src/client/src/hooks/use-pipeline-events.ts
+++ b/src/client/src/hooks/use-pipeline-events.ts
@@ -81,7 +81,7 @@ export function usePipelineEvents({ projectId }: UsePipelineEventsProps) {
             setProjectStatus("generating");
             break;
 
-          case "SCENE_PROGRESS":
+          case "SCENE_UPDATE":
             updateSceneClientSide(parsedEvent.payload.scene.id, (scene) => {
               const ignored = useStore.getState().ignoreAssetUrls;
               // const updates: Partial<Scene> = {
diff --git a/src/client/src/pages/Dashboard.tsx b/src/client/src/pages/Dashboard.tsx
index 78dc32d..dd113ed 100644
--- a/src/client/src/pages/Dashboard.tsx
+++ b/src/client/src/pages/Dashboard.tsx
@@ -359,8 +359,8 @@ export default function Dashboard() {
                 <MetricCard
                   label="Quality Score"
                   value={
-                    currentMetrics?.sceneMetrics?.length && currentMetrics?.sceneMetrics?.length > 0
-                      ? `${Math.round(currentMetrics.sceneMetrics.reduce((a, m) => a + m.finalScore, 0) / currentMetrics.sceneMetrics.length)}%`
+                    currentMetrics?.sceneMetrics?.[ selectedScene?.id ?? "" ]?.length > 0
+                      ? `${Math.round(currentMetrics.sceneMetrics?.[ selectedScene?.id ?? "" ].reduce((a, m) => a + m.finalScore, 0) / currentMetrics.sceneMetrics?.[ selectedScene?.id ?? "" ].length)}%`
                       : "0%"
                   }
                   trend={ currentMetrics?.globalTrend?.qualityTrendSlope && currentMetrics?.globalTrend?.qualityTrendSlope > 0 ? "up" : "neutral" }
@@ -370,8 +370,8 @@ export default function Dashboard() {
                 <MetricCard
                   label="Avg Duration"
                   value={
-                    currentMetrics?.sceneMetrics?.length && currentMetrics?.sceneMetrics?.length > 0
-                      ? `${(currentMetrics.sceneMetrics.reduce((a, m) => a + m.duration, 0) / currentMetrics.sceneMetrics.length / 60).toFixed(1)}m`
+                    currentMetrics?.sceneMetrics?.length && currentMetrics?.sceneMetrics?.[ selectedScene?.id ?? "" ]?.length > 0
+                      ? `${(currentMetrics.sceneMetrics?.[ selectedScene?.id ?? "" ].reduce((a, m) => a + m.duration, 0) / currentMetrics.sceneMetrics?.[ selectedScene?.id ?? "" ].length / 60).toFixed(1)}m`
                       : "0.0m"
                   }
                   subValue="per scene"
@@ -379,7 +379,7 @@ export default function Dashboard() {
                 />
                 <MetricCard
                   label="Rules Added"
-                  value={ currentMetrics?.sceneMetrics?.filter(m => m.ruleAdded).length ?? 0 }
+                  value={ currentMetrics?.sceneMetrics?.[ selectedScene?.id ?? "" ]?.filter(m => m.ruleAdded).length ?? 0 }
                   subValue="this session"
                   icon={ <Zap className="w-5 h-5" /> }
                 />
@@ -394,7 +394,7 @@ export default function Dashboard() {
             <CardContent className="p-4 pt-0">
               <div className="space-y-2">
                 { (!currentMetrics?.sceneMetrics || clientIsLoading) ? historySkeletons : (
-                  currentMetrics.sceneMetrics.map((m) => (
+                  currentMetrics.sceneMetrics?.[ selectedScene?.id ?? "" ]?.map((m) => (
                     <div
                       key={ m.sceneId }
                       className="flex items-center justify-between p-2 rounded-md bg-muted/50"
diff --git a/src/pipeline/helpers/assert-job.ts b/src/pipeline/helpers/assert-job.ts
index d0f2feb..0a0fbd8 100644
--- a/src/pipeline/helpers/assert-job.ts
+++ b/src/pipeline/helpers/assert-job.ts
@@ -3,7 +3,8 @@ import { JobState } from "../../shared/types/job.types";
 const transitions: Record<JobState, JobState[]> = {
     CREATED: [ "RUNNING", "CANCELLED" ],
     RUNNING: [ "COMPLETED", "FAILED", "CANCELLED" ],
-    FAILED: [ "RUNNING", "CANCELLED" ],
+    FAILED: [ "RUNNING", "FATAL", "CANCELLED" ],
+    FATAL: [],
     COMPLETED: [],
     CANCELLED: [],
 };
diff --git a/src/pipeline/helpers/domain/character-mappers.ts b/src/pipeline/helpers/domain/character-mappers.ts
index 466fafe..3f9b175 100644
--- a/src/pipeline/helpers/domain/character-mappers.ts
+++ b/src/pipeline/helpers/domain/character-mappers.ts
@@ -1,10 +1,10 @@
-import { characters } from "../../../shared/schema";
+import { characters } from "../../../shared/db/schema";
 import {
     Character
 } from "../../../shared/types/workflow.types";
 import {
     CharacterEntity
-} from "../../../shared/zod-db";
+} from "../../../shared/db/zod-db";
 
 export function mapDbCharacterToDomain(entity: CharacterEntity): Character {
     const character: Character = {
diff --git a/src/pipeline/helpers/domain/location-mappers.ts b/src/pipeline/helpers/domain/location-mappers.ts
index f9d704c..29c7926 100644
--- a/src/pipeline/helpers/domain/location-mappers.ts
+++ b/src/pipeline/helpers/domain/location-mappers.ts
@@ -1,10 +1,10 @@
-import { locations } from "../../../shared/schema";
+import { locations } from "../../../shared/db/schema";
 import {
     Location
 } from "../../../shared/types/workflow.types";
 import {
     LocationEntity
-} from "../../../shared/zod-db";
+} from "../../../shared/db/zod-db";
 
 export function mapDbLocationToDomain(entity: LocationEntity): Location {
     const location: Location = {
diff --git a/src/pipeline/helpers/domain/project-mappers.ts b/src/pipeline/helpers/domain/project-mappers.ts
index f98d13e..7e48ded 100644
--- a/src/pipeline/helpers/domain/project-mappers.ts
+++ b/src/pipeline/helpers/domain/project-mappers.ts
@@ -5,7 +5,7 @@ import {
 } from "../../../shared/types/workflow.types";
 import {
     ProjectEntity
-} from "../../../shared/zod-db";
+} from "../../../shared/db/zod-db";
 
 interface MapDBProjectToDomainProps {
     project: ProjectEntity,
@@ -44,14 +44,13 @@ export function mapDbProjectToDomain(
         createdAt: entity.createdAt,
         updatedAt: entity.updatedAt,
         metadata: entity.metadata,
-        metrics: entity.metrics,
+        metrics: entity.metrics || createDefaultMetrics(),
         status: entity.status,
         currentSceneIndex: entity.currentSceneIndex,
         forceRegenerateSceneIds: entity.forceRegenerateSceneIds,
         generationRules: entity.generationRules,
         generationRulesHistory: entity.generationRulesHistory,
         assets: entity.assets,
-        audioAnalysis: entity.audioAnalysis,
         storyboard: {
             metadata: entity.metadata,
             scenes: scenes,
diff --git a/src/pipeline/helpers/domain/scene-mappers.ts b/src/pipeline/helpers/domain/scene-mappers.ts
index c031015..66c4eba 100644
--- a/src/pipeline/helpers/domain/scene-mappers.ts
+++ b/src/pipeline/helpers/domain/scene-mappers.ts
@@ -1,10 +1,10 @@
-import { scenes } from "../../../shared/schema";
+import { scenes } from "../../../shared/db/schema";
 import {
     Scene,
 } from "../../../shared/types/workflow.types";
 import {
     SceneEntity
-} from "../../../shared/zod-db";
+} from "../../../shared/db/zod-db";
 
 export function mapDbSceneToDomain(entity: SceneEntity): Scene {
     return {
diff --git a/src/pipeline/helpers/stream-helper.ts b/src/pipeline/helpers/stream-helper.ts
index 4e258f2..c377662 100644
--- a/src/pipeline/helpers/stream-helper.ts
+++ b/src/pipeline/helpers/stream-helper.ts
@@ -22,7 +22,8 @@ export async function streamWithInterruptHandling(
             initialState,
             {
                 ...runnableConfig,
-                streamMode: [ "values" ]
+                streamMode: [ "values" ],
+                recursionLimit: 100,
             }
         );
 
diff --git a/src/pipeline/index.ts b/src/pipeline/index.ts
index d7b1be2..dc0ee6c 100644
--- a/src/pipeline/index.ts
+++ b/src/pipeline/index.ts
@@ -21,7 +21,7 @@ import { handleRegenerateFrameCommand } from './handlers/handleRegenerateFrameCo
 import { handleUpdateSceneAssetCommand } from './handlers/handleUpdateSceneAssetCommand';
 import { handleResolveInterventionCommand } from './handlers/handleResolveInterventionCommand';
 import { handleStopPipelineCommand } from './handlers/handleStopPipelineCommand';
-import { formatLoggers, logContextStore, LogContext } from "../shared/format-loggers";
+import { initLogger, logContextStore, LogContext } from "../shared/logger";
 import { WorkflowOperator } from "./services/workflow-service";
 import { DistributedLockManager } from "./services/lock-manager";
 import { v7 as uuidv7 } from 'uuid';
@@ -30,6 +30,10 @@ import { JobControlPlane } from "./services/job-control-plane";
 import { ProjectRepository } from "./project-repository";
 import { handleJobCompletion } from "./handlers/handleJobCompletion";
 import { JobLifecycleMonitor } from "./services/job-lifecycle-monitor";
+import { CinematicVideoWorkflow } from "../workflow/graph";
+import * as fs from 'node:fs/promises';
+import * as path from 'node:path';
+import { ensureSubscription, ensureTopic } from "@shared/utils/pubsub-utils";
 
 
 
@@ -39,6 +43,9 @@ if (!gcpProjectId) throw Error("A GCP projectId was not provided");
 const postgresUrl = process.env.POSTGRES_URL;
 if (!postgresUrl) throw Error("Postgres URL is required for CheckpointerManager initialization");
 
+const bucketName = process.env.GCP_BUCKET_NAME!;
+if (!bucketName) throw new Error("GCP_BUCKET_NAME environment variable not set.");
+
 const workerId = uuidv7();
 
 const checkpointerManager = new CheckpointerManager(postgresUrl);
@@ -62,11 +69,12 @@ const pubsub = new PubSub({
 });
 
 const PIPELINE_CANCELLATIONS_SUBSCRIPTION_NAME = `worker-${workerId}-cancellations`;
+
 const jobEventsTopicPublisher = pubsub.topic(JOB_EVENTS_TOPIC_NAME);
 const videoEventsTopicPublisher = pubsub.topic(PIPELINE_EVENTS_TOPIC_NAME);
 
 export async function publishJobEvent(event: JobEvent) {
-    console.log(`[Pipeline] Publishing job event ${event.type} to ${JOB_EVENTS_TOPIC_NAME}`);
+    console.log(`[Pipeline] Publishing: ${event.type}`, { topic: JOB_EVENTS_TOPIC_NAME });
     const dataBuffer = Buffer.from(JSON.stringify(event));
     await jobEventsTopicPublisher.publishMessage({
         data: dataBuffer,
@@ -82,7 +90,7 @@ export async function publishPipelineEvent(event: PipelineEvent) {
 }
 
 const logContext: LogContext = {
-    workerId,
+    w_id: workerId,
     correlationId: uuidv7(),
     shouldPublishLog: false,
 };
@@ -92,66 +100,77 @@ const isDev = process.env.NODE_ENV !== 'production';
 
 async function main() {
 
-    formatLoggers(
-        { getStore: logContextStore.getStore.bind(logContextStore) },
-        publishPipelineEvent
-    );
+    initLogger(publishPipelineEvent);
     console.log(`Starting pipeline service ${workerId}...`);
-    await logContextStore.run(logContext, async () => {
 
+    await logContextStore.run(logContext, async () => {
         try {
-        const jobControlPlane = new JobControlPlane(poolManager, publishJobEvent);
-        const jobLifecycleMonitor = JobLifecycleMonitor.getInstance(jobControlPlane);
-        jobLifecycleMonitor.start();
+
+            const jobControlPlane = new JobControlPlane(poolManager, publishJobEvent);
+            const jobLifecycleMonitor = JobLifecycleMonitor.getInstance(jobControlPlane);
+            jobLifecycleMonitor.start();
 
             checkpointerManager.getCheckpointer();
-        const projectRepository = new ProjectRepository();
-            const workflowOperator = new WorkflowOperator(checkpointerManager, jobControlPlane, publishPipelineEvent, projectRepository, lockManager);
+            const projectRepository = new ProjectRepository();
+            const workflowOperator = new WorkflowOperator(checkpointerManager, jobControlPlane, publishPipelineEvent, projectRepository, lockManager, gcpProjectId!, bucketName);
+
+            if (process.env.DEBUG === 'true' || process.env.NODE_ENV === 'development') {
+
+                const testWorkflow = new CinematicVideoWorkflow({
+                    gcpProjectId: gcpProjectId!,
+                    projectId: "test",
+                    bucketName: bucketName,
+                    jobControlPlane: jobControlPlane,
+                    lockManager: lockManager,
+                    controller: new AbortController(),
+                });
 
-        const [ jobEventsTopic ] = await pubsub.topic(JOB_EVENTS_TOPIC_NAME).get({ autoCreate: true });
-            console.log(`[Pipeline ${workerId}] Ensuring topic ${JOB_EVENTS_TOPIC_NAME} exists...`);
+                const compiled = testWorkflow.graph.compile();
+                const graphData = await compiled.getGraphAsync();
 
-        const ensureSubscription = async (topic: Topic, subscriptionName: string, filter?: string) => {
-            console.log(`[Pipeline ${workerId}] Ensuring subscription ${subscriptionName} exists on ${topic.name}...`);
+                const mermaidText = graphData.drawMermaid();
+                const textPath = path.resolve('./docs/graph_structure.mmd');
+                await fs.writeFile(textPath, mermaidText);
+                console.debug(`[Debug]: Graph definition saved: file://${textPath}`);
 
-            try {
-                await topic.createSubscription(subscriptionName, {
-                    enableExactlyOnceDelivery: true,
-                    ackDeadlineSeconds: 60,
-                    expirationPolicy: { ttl: { seconds: 24 * 60 * 60 } },
-                    filter
-                });
-            } catch (e: any) {
-                if (e.code !== 6) throw e;
+                try {
+                    const pngBlob = await graphData.drawMermaidPng();
+                    const pngBuffer = Buffer.from(await pngBlob.arrayBuffer());
+                    const pngPath = path.resolve('./docs/graph_diagram.png');
+                    await fs.writeFile(pngPath, pngBuffer);
+                    console.debug(`[Debug]: Graph image saved: file://${pngPath}`);
+                } catch (e) {
+                    console.warn("[Debug]: Failed to generate PNG. (Ensure 'canvas' or 'playwright' is available if required by your environment).");
+                }
             }
-        };
 
-            await ensureSubscription(jobEventsTopic, PIPELINE_JOB_EVENTS_SUBSCRIPTION, 'attributes.type = "JOB_COMPLETED" OR attributes.type = "JOB_FAILED"');
-        await ensureSubscription(jobEventsTopic, WORKER_JOB_EVENTS_SUBSCRIPTION, 'attributes.type = "JOB_DISPATCHED"');
+            const jobEventsTopic = await ensureTopic(pubsub, JOB_EVENTS_TOPIC_NAME);
+            const videoCommandsTopic = await ensureTopic(pubsub, PIPELINE_COMMANDS_TOPIC_NAME);
+            const videoCancellationsTopic = await ensureTopic(pubsub, PIPELINE_CANCELLATIONS_TOPIC_NAME);
+            await ensureTopic(pubsub, PIPELINE_EVENTS_TOPIC_NAME);
 
-        const workerEventsSubscription = pubsub.subscription(PIPELINE_JOB_EVENTS_SUBSCRIPTION);
-        console.log(`[Pipeline ${workerId}] Listening for job events on ${PIPELINE_JOB_EVENTS_SUBSCRIPTION}`);
-
-        const [ videoCommandsTopic ] = await pubsub.topic(PIPELINE_COMMANDS_TOPIC_NAME).get({ autoCreate: true });
-        await pubsub.topic(PIPELINE_EVENTS_TOPIC_NAME).get({ autoCreate: true });
-        await ensureSubscription(videoCommandsTopic, PIPELINE_COMMANDS_SUBSCRIPTION);
-        console.log(`[Pipeline ${workerId} Listening for pipeline commands on ${PIPELINE_COMMANDS_SUBSCRIPTION}`);
+            await ensureSubscription(jobEventsTopic, PIPELINE_JOB_EVENTS_SUBSCRIPTION, {
+                filter: 'attributes.type = "JOB_COMPLETED" OR attributes.type = "JOB_FAILED"'
+            });
+            await ensureSubscription(jobEventsTopic, WORKER_JOB_EVENTS_SUBSCRIPTION, {
+                filter: 'attributes.type = "JOB_DISPATCHED"'
+            });
+            await ensureSubscription(videoCommandsTopic, PIPELINE_COMMANDS_SUBSCRIPTION);
+            console.log(`[Pipeline ${workerId} Listening for pipeline commands on ${PIPELINE_COMMANDS_SUBSCRIPTION}`);
 
-            const [ videoCancellationsTopic ] = await pubsub.topic(PIPELINE_CANCELLATIONS_TOPIC_NAME).get({ autoCreate: true });
-        try {
-            await videoCancellationsTopic.createSubscription(PIPELINE_CANCELLATIONS_SUBSCRIPTION_NAME, {
-                enableExactlyOnceDelivery: true,
+            await ensureSubscription(videoCancellationsTopic, PIPELINE_CANCELLATIONS_SUBSCRIPTION_NAME, {
                 ackDeadlineSeconds: 30,
-                expirationPolicy: { ttl: { seconds: 12 * 60 * 60 } }, // 12h expiration for cancellations
+                expirationPolicy: { ttl: { seconds: 12 * 60 * 60 } }
             });
-        } catch (e: any) {
-            if (e.code !== 6) throw e;
-        }
-        const cancellationSubscription = pubsub.subscription(PIPELINE_CANCELLATIONS_SUBSCRIPTION_NAME);
-        console.log(`[Pipeline ${workerId}] Listening for cancellations on ${PIPELINE_CANCELLATIONS_SUBSCRIPTION_NAME}`);
 
-        const pipelineCommandsSubscription = pubsub.subscription(PIPELINE_COMMANDS_SUBSCRIPTION);
-        console.log(`Listening for commands on ${PIPELINE_COMMANDS_SUBSCRIPTION}...`);
+            const workerEventsSubscription = pubsub.subscription(PIPELINE_JOB_EVENTS_SUBSCRIPTION);
+            console.log(`[Pipeline ${workerId}] Listening for job events on ${PIPELINE_JOB_EVENTS_SUBSCRIPTION}`);
+
+            const cancellationSubscription = pubsub.subscription(PIPELINE_CANCELLATIONS_SUBSCRIPTION_NAME);
+            console.log(`[Pipeline ${workerId}] Listening for cancellations on ${PIPELINE_CANCELLATIONS_SUBSCRIPTION_NAME}`);
+
+            const pipelineCommandsSubscription = pubsub.subscription(PIPELINE_COMMANDS_SUBSCRIPTION);
+            console.log(`Listening for commands on ${PIPELINE_COMMANDS_SUBSCRIPTION}...`);
 
 
             workerEventsSubscription.on("message", async (message) => {
@@ -167,7 +186,7 @@ async function main() {
                 }
 
                 if (event && 'type' in event && event.type.startsWith('JOB_')) {
-                    await logContextStore.run({ ...logContext, jobId: event.jobId, shouldPublishLog: true }, async () => {
+                    await logContextStore.run({ ...logContext, jobId: event.jobId, shouldPublishLog: false }, async () => {
 
                         const { jobId } = event;
                         if (event.type === 'JOB_COMPLETED') {
@@ -181,46 +200,58 @@ async function main() {
                                     console.warn(`[Pipeline.jobFailed] Job ${jobId} not found or not completed`);
                                     return;
                                 }
-
-                            const { maxRetries } = job;
-                            const nextAttempt = job.attempt + 1;
-                            const isPermanentlyFailed = nextAttempt > maxRetries;
-
-                            await jobControlPlane.updateJobSafe(jobId, job.attempt, {
-                                state: isPermanentlyFailed ? "FATAL" : "FAILED",
-                                error: job.error,
-                                attempt: nextAttempt,
-                                updatedAt: new Date()
-                            });
-
-                            console.warn(`[Job ${jobId}] ${isPermanentlyFailed ? 'Max retries reached' : 'Marked for retry'}`); return;
-                        } catch (err) {
-                            console.error("[Pipeline] Error handling job failure:", err);
+                                try {
+
+                                    const { maxRetries } = job;
+                                    const nextAttempt = job.attempt + 1; ``;
+                                    const isPermanentlyFailed = nextAttempt > maxRetries;
+
+                                    await jobControlPlane.updateJobSafe(jobId, job.attempt, {
+                                        state: isPermanentlyFailed ? "FATAL" : "FAILED",
+                                        error: job.error,
+                                        attempt: nextAttempt,
+                                        updatedAt: new Date()
+                                    });
+
+                                    console.warn(`[Job ${jobId}] ${isPermanentlyFailed ? 'Max retries reached' : 'Marked for retry'}`);
+                                    if (isPermanentlyFailed) {
+                                        publishPipelineEvent({
+                                            type: "WORKFLOW_FAILED",
+                                            projectId: job.projectId,
+                                            payload: { error: job.error || `Job ${jobId} (${job.type}) failed` },
+                                            timestamp: new Date().toISOString(),
+                                        });
+                                    }
+                                    return;
+                                } catch (error) {
+                                    console.error("[Pipeline] Error handling job failure:", { error });
+                                }
+                            } catch (error) {
+                                console.error("[Pipeline] Error retrieving job:", { error });
+                            }
                         }
-                    }
-
                     });
                 }
                 await message.ackWithResponse();
             });
 
 
-        cancellationSubscription.on("message", async (message) => {
+            cancellationSubscription.on("message", async (message) => {
 
-            console.log(`[Pipeline ${workerId}] Received cancellation message: ${message.data.toString()}`);
-            try {
-                const payload = JSON.parse(message.data.toString());
-                if (payload.projectId) {
+                console.log(`[Pipeline ${workerId}] Received cancellation message: ${message.data.toString()}`);
+                try {
+                    const payload = JSON.parse(message.data.toString());
+                    if (payload.projectId) {
 
-                    await logContextStore.run({ ...logContext, projectId: payload.projectId, shouldPublishLog: true }, async () => {
-                        await workflowOperator.stopPipeline(payload.projectId);
-                    });
+                        await logContextStore.run({ ...logContext, projectId: payload.projectId, shouldPublishLog: true }, async () => {
+                            await workflowOperator.stopPipeline(payload.projectId);
+                        });
+                    }
+                } catch (err) {
+                    console.error("Error processing cancellation message:", err);
                 }
-            } catch (err) {
-                console.error("Error processing cancellation message:", err);
-            }
-            await message.ackWithResponse();
-        });
+                await message.ackWithResponse();
+            });
 
             const publishCancellation = async (projectId: string) => {
 
@@ -292,17 +323,18 @@ async function main() {
             process.on("SIGINT", async () => {
 
                 console.log("Shutting down worker...");
+
                 jobLifecycleMonitor.stop();
 
-                workerEventsSubscription.close();
-                cancellationSubscription.close();
-                pipelineCommandsSubscription.close();
+                [ workerEventsSubscription, cancellationSubscription, pipelineCommandsSubscription ].forEach((sub) => sub.close());
                 try {
-                    console.log("Deleting ephemeral subscription...");
-                    await workerEventsSubscription.delete();
-                    await cancellationSubscription.delete();
-                    await pipelineCommandsSubscription.delete();
-                    console.log("Deleted ephemeral cancellation subscription");
+                    console.log("Deleting subscriptions ");
+                    await Promise.all([
+                        workerEventsSubscription.delete(),
+                        cancellationSubscription.delete(),
+                        pipelineCommandsSubscription.delete()
+                    ]);
+                    console.log("Deleted subscriptions");
                 } catch (e) {
                     console.error("Failed to delete subscription (it might have been deleted already or connection failed)", e);
                 }
@@ -317,11 +349,10 @@ async function main() {
                     pipelineCommandsSubscription.close();
                 });
             }
-    } catch (error) {
-        console.error(`[Pipeline ${workerId}] FATAL: PubSub initialization failed:`, error);
-        console.error(`[Pipeline ${workerId}] Service cannot start without PubSub. Shutting down...`);
-        process.exit(1);
-    }
+        } catch (error) {
+            console.error(`[Pipeline ${workerId}] FATAL: PubSub initialization failed:`, error);
+            process.exit(1);
+        }
     });
 }
 
diff --git a/src/pipeline/project-repository.ts b/src/pipeline/project-repository.ts
index 9a9572d..ad51e5b 100644
--- a/src/pipeline/project-repository.ts
+++ b/src/pipeline/project-repository.ts
@@ -1,5 +1,5 @@
 import { db } from "../shared/db";
-import { scenes, projects, characters, locations, jobs } from "../shared/schema";
+import { scenes, projects, characters, locations, jobs } from "../shared/db/schema";
 import { eq, asc, inArray, sql, } from "drizzle-orm";
 import {
     Scene, Location, Project, InitialProject,
@@ -7,7 +7,7 @@ import {
 } from "../shared/types/workflow.types";
 import {
     DbProjectSchema, DbSceneSchema, DbCharacterSchema, DbLocationSchema, ProjectEntity,
-} from "../shared/zod-db";
+} from "../shared/db/zod-db";
 import { mapDbProjectToDomain } from "./helpers/domain/project-mappers";
 import { mapDbSceneToDomain, mapDomainSceneToDb } from "./helpers/domain/scene-mappers";
 import { mapDbCharacterToDomain, mapDomainCharacterToDb } from "./helpers/domain/character-mappers";
diff --git a/src/pipeline/services/command-handler.ts b/src/pipeline/services/command-handler.ts
index 1af3ded..8300884 100644
--- a/src/pipeline/services/command-handler.ts
+++ b/src/pipeline/services/command-handler.ts
@@ -1,5 +1,5 @@
 import { db } from "../../shared/db";
-import { projects, scenes, jobs } from "../../shared/schema";
+import { projects, scenes, jobs } from "../../shared/db/schema";
 import { 
   RegenerateSceneCommand, 
   UpdateSceneAssetCommand 
diff --git a/src/pipeline/services/job-control-plane.ts b/src/pipeline/services/job-control-plane.ts
index 5371bd8..9fddfce 100644
--- a/src/pipeline/services/job-control-plane.ts
+++ b/src/pipeline/services/job-control-plane.ts
@@ -3,7 +3,7 @@ import { PoolManager } from "./pool-manager";
 import { db, schema } from "../../shared/db";
 import { eq, and, sql, desc, count, isNull } from "drizzle-orm";
 import { createHash } from 'crypto';
-import { jobs } from "@shared/schema";
+import { jobs } from "@shared/db/schema";
 import { drizzle } from "drizzle-orm/node-postgres";
 
 
@@ -130,11 +130,10 @@ export class JobControlPlane {
 
     /**
      * Claims a job when only the jobId is known. 
-     * Performs an internal lookup to identify the project and enforce concurrency limits.
      * @param jobId - Unique ID of the job to claim.
-     * @returns The claimed JobRecord (with projectId revived) or null.
+     * @returns A tuple of [JobRecord, string (ISO timestamp)] or null.
      */
-    async claimJob(jobId: string): Promise<JobRecord | null> {
+    async claimJob(jobId: string): Promise<[ JobRecord, string ] | null> {
 
         return await this.poolManager.transaction(async (client) => {
             const discovery = await client.query(
@@ -165,13 +164,24 @@ export class JobControlPlane {
 
             if (count >= limit) return null;
 
+            // Capture the claim time
+            const claimTime = new Date();
+
             const [ claimedJob ] = await tx
                 .update(jobs)
-                .set({ state: "RUNNING", updatedAt: new Date() })
+                .set({
+                    state: "RUNNING",
+                    updatedAt: claimTime // Use the same timestamp for DB consistency
+                })
                 .where(and(eq(jobs.id, jobId), eq(jobs.state, "CREATED")))
                 .returning();
 
-            return claimedJob ? this.reviveDates(claimedJob) : null;
+            if (!claimedJob) return null;
+
+            const revivedJob = this.reviveDates(claimedJob);
+
+            // Return as a tuple: [JobRecord, ISO String]
+            return [ revivedJob, claimTime.toISOString() ];
         });
     }
 
@@ -185,7 +195,7 @@ export class JobControlPlane {
     async requeueJob(jobId: string, currentAttempt: number, context: 'STALE_RECOVERY' | 'BACKOFF_RETRY'): Promise<void> {
         const auditLog = ` [Monitor] Action: ${context} at ${new Date().toISOString()}`;
 
-        const result = await this.updateJobSafe(jobId, currentAttempt, {
+        const result = await this.updateJobSafeAndIncrementAttempt(jobId, currentAttempt, {
             state: "CREATED",
             error: sql<string>`COALESCE(${jobs.error}, '') || ${auditLog}` as any,
         });
@@ -230,10 +240,43 @@ export class JobControlPlane {
     async updateJobSafe(
         jobId: string,
         currentAttempt: number,
-        updates: Partial<typeof jobs.$inferInsert>
+        updates?: Partial<JobRecord>,
+    ) {
+        const [ result ] = await db.update(jobs)
+            .set({
+                ...updates,
+                updatedAt: new Date(),
+            })
+            .where(and(
+                eq(jobs.id, jobId),
+                eq(jobs.attempt, currentAttempt) // Guard: only update if attempt matches
+            ))
+            .returning();
+
+        if (!result) {
+            console.warn(`OptimisticLockError: Job ${jobId} was not updated. It was possibly updated by another process.`);
+            return null;
+        }
+
+        return this.reviveDates(result) as JobRecord;
+    }
+
+    /**
+     * Updates job data using an Optimistic Locking pattern via the 'attempt' column.
+     * Ensures that a worker cannot overwrite a job that has been retried or cancelled elsewhere.
+     * * @param jobId - ID of the job to update.
+     * @param currentAttempt - The version (attempt count) the worker expects to update.
+     * @param updates - Partial job data to apply.
+     * @throws {Error} If the job attempt has changed, indicating a concurrent modification.
+     * @returns The updated JobRecord.
+     */
+    async updateJobSafeAndIncrementAttempt(
+        jobId: string,
+        currentAttempt: number,
+        updates?: Partial<typeof jobs.$inferInsert>
     ) {
         // Remove 'attempt' from updates if it was passed in to prevent double-increment
-        const { attempt, ...rest } = updates;
+        const { attempt, ...rest } = updates || {};
 
         const [ result ] = await db.update(jobs)
             .set({
@@ -248,7 +291,7 @@ export class JobControlPlane {
             .returning();
 
         if (!result) {
-            console.warn(`OptimisticLockError: Job ${jobId} was updated by another process.`);
+            console.warn(`OptimisticLockError: Job ${jobId} was not updated. It was possibly updated by another process.`);
             return null;
         }
 
diff --git a/src/pipeline/services/job-lifecycle-monitor.ts b/src/pipeline/services/job-lifecycle-monitor.ts
index 2271d1d..ba21d8a 100644
--- a/src/pipeline/services/job-lifecycle-monitor.ts
+++ b/src/pipeline/services/job-lifecycle-monitor.ts
@@ -1,5 +1,5 @@
 import { db } from "../../shared/db";
-import { jobs } from "../../shared/schema";
+import { jobs } from "../../shared/db/schema";
 import { and, eq, sql } from "drizzle-orm";
 import { JobControlPlane } from "./job-control-plane";
 
@@ -21,7 +21,7 @@ export class JobLifecycleMonitor {
     }
 
     public start(frequencyMs: number = 60000) {
-        console.log("[JobLifecycleMonitor] Starting...");
+        console.log("[Monitor] Starting...");
         if (this.isRunning) return;
         this.isRunning = true;
         this.interval = setInterval(() => this.maintenanceCycle(), frequencyMs);
@@ -29,14 +29,14 @@ export class JobLifecycleMonitor {
 
     private async maintenanceCycle() {
 
-        console.log("[JobLifecycleMonitor] maintenanceCycle");
+        console.log("[Monitor] Cycle");
         try {
             await Promise.all([
                 this.processStaleJobs(),
                 this.processRetryableJobs()
             ]);
         } catch (error) {
-            console.error("[JobLifecycleMonitor] maintenanceCycle failed:", error);
+            console.error("[Monitor] Cycle failed:", error);
         }
     }
 
@@ -45,7 +45,7 @@ export class JobLifecycleMonitor {
      */
     private async processStaleJobs() {
 
-        console.log("[JobLifecycleMonitor] processStaleJobs");
+        console.log("[Monitor] processStale");
         const staleJobs = await db.select({ id: jobs.id, attempt: jobs.attempt })
             .from(jobs)
             .where(and(
@@ -64,7 +64,7 @@ export class JobLifecycleMonitor {
      */
     private async processRetryableJobs() {
 
-        console.log("[JobLifecycleMonitor] processRetryableJobs");
+        console.log("[Monitor] processRetryable");
         const retryableJobs = await db.select({ id: jobs.id, attempt: jobs.attempt })
             .from(jobs)
             .where(and(
@@ -79,7 +79,7 @@ export class JobLifecycleMonitor {
     }
 
     public stop() {
-        console.log("[JobLifecycleMonitor] Stopping...");
+        console.log("[Monitor] Stopping...");
         if (this.interval) clearInterval(this.interval!);
         this.isRunning = false;
     }
diff --git a/src/pipeline/services/pool-manager.ts b/src/pipeline/services/pool-manager.ts
index 968651c..c6fbf47 100644
--- a/src/pipeline/services/pool-manager.ts
+++ b/src/pipeline/services/pool-manager.ts
@@ -120,24 +120,24 @@ export class PoolManager extends EventEmitter {
     private setupPoolEventHandlers() {
         // Connection acquired
         this.pool.on('connect', (client: PoolClient) => {
-            console.log('[Pool] New connection established');
             this.metrics.totalConnections++;
+            console.log('[Pool] new conn', { totalConnections: this.metrics.totalConnections });
         });
 
         // Connection released back to pool
         this.pool.on('acquire', (client: PoolClient) => {
-            console.log('[Pool] Connection acquired from pool');
+            console.log('[Pool] conn acquired');
         });
 
         // Connection removed from pool
         this.pool.on('remove', (client: PoolClient) => {
-            console.log('[Pool] Connection removed from pool');
             this.metrics.totalConnections--;
+            console.log('[Pool] conn removed', { totalConnections: this.metrics.totalConnections });
         });
 
         // Error occurred
         this.pool.on('error', (err: Error, client: PoolClient) => {
-            console.error('[Pool] Unexpected error on idle client:', err);
+            console.error('[Pool] idle error:', err);
             this.handlePoolError(err);
         });
     }
@@ -161,7 +161,7 @@ export class PoolManager extends EventEmitter {
 
         if (this.circuitState === 'open') return;
 
-        console.error('[Pool] Circuit breaker OPENED - too many errors');
+        console.error('[Pool] Breaker OPENED - too many errors');
         this.circuitState = 'open';
         this.emit('circuit-open');
 
@@ -171,7 +171,7 @@ export class PoolManager extends EventEmitter {
         }
 
         this.circuitResetTimer = setTimeout(() => {
-            console.log('[Pool] Circuit breaker entering HALF-OPEN state');
+            console.log('[Pool] Breaker entering HALF-OPEN state');
             this.circuitState = 'half-open';
             this.errorCount = 0;
             this.emit('circuit-half-open');
@@ -181,7 +181,7 @@ export class PoolManager extends EventEmitter {
     private closeCircuit() {
         if (this.circuitState === 'closed') return;
 
-        console.log('[Pool] Circuit breaker CLOSED - system recovered');
+        console.log('[Pool] Breaker CLOSED - system recovered');
         this.circuitState = 'closed';
         this.errorCount = 0;
         this.emit('circuit-closed');
@@ -193,7 +193,7 @@ export class PoolManager extends EventEmitter {
     async getConnection(): Promise<PoolClient> {
 
         if (this.circuitState === 'open' && !IS_DEBUG_MODE) {
-            throw new Error('Connection pool circuit breaker is OPEN - refusing connections');
+            throw new Error('[Pool] Breaker OPEN - refusing conns');
         }
 
         const startTime = Date.now();
@@ -204,7 +204,7 @@ export class PoolManager extends EventEmitter {
             this.metrics.acquisitionTimeMs = acquisitionTime;
 
             if (acquisitionTime > 1000) {
-                console.warn("Slow connection acquisition", { acquisitionTime, total: this.metrics.totalConnections })
+                console.warn("Slow conn acquisition", { acquisitionTime, total: this.metrics.totalConnections })
             }
 
             this.trackConnection(client);
@@ -222,7 +222,7 @@ export class PoolManager extends EventEmitter {
             return client;
 
         } catch (error: any) {
-            console.error('[Pool] Failed to acquire connection:', error.message);
+            console.error('[Pool] Failed to acquire conn:', error.message);
             this.handlePoolError(error);
             throw error;
         }
@@ -298,7 +298,7 @@ export class PoolManager extends EventEmitter {
         this.healthCheckInterval = setInterval(async () => {
             try {
                 await this.query('SELECT 1');
-                console.log('[Pool] Health check passed');
+                console.log('[Pool] HC');
             } catch (error: any) {
                 console.error('[Pool] Health check failed:', error.message);
                 this.handlePoolError(error);
@@ -316,7 +316,7 @@ export class PoolManager extends EventEmitter {
                 // Warn if connection held too long
                 if (age > 30000) {
                     console.warn(
-                        `[Pool] Connection leak detected! Held for ${Math.round(age / 1000)}s\n` +
+                        `[Pool] Conn leak detected! Held for ${Math.round(age / 1000)}s\n` +
                         `Acquisition stack:\n${info.stack}`
                     );
 
@@ -361,19 +361,19 @@ export class PoolManager extends EventEmitter {
      * Drain pool connections (for testing or shutdown)
      */
     async drain(): Promise<void> {
-        console.log('[Pool] Draining connection pool...');
+        console.log('[Pool] Draining conn pool...');
 
         // Wait for active connections to finish (with timeout)
         const timeout = 30000;
         const startTime = Date.now();
 
         while (this.activeConnections.size > 0 && Date.now() - startTime < timeout) {
-            console.log(`[Pool] Waiting for ${this.activeConnections.size} active connections...`);
+            console.log(`[Pool] Waiting for ${this.activeConnections.size} active conns...`);
             await new Promise(resolve => setTimeout(resolve, 1000));
         }
 
         if (this.activeConnections.size > 0) {
-            console.warn(`[Pool] Forcing closure with ${this.activeConnections.size} active connections`);
+            console.warn(`[Pool] Forcing closure with ${this.activeConnections.size} active conns`);
         }
     }
 
@@ -381,7 +381,7 @@ export class PoolManager extends EventEmitter {
      * Close pool and cleanup
      */
     async close(): Promise<void> {
-        console.log('[Pool] Closing connection pool...');
+        console.log('[Pool] Closing conn pool...');
 
         // Stop all intervals
         if (this.metricsInterval) clearInterval(this.metricsInterval);
@@ -393,6 +393,6 @@ export class PoolManager extends EventEmitter {
         await this.drain();
         await this.pool.end();
 
-        console.log('[Pool] Connection pool closed');
+        console.log('[Pool] Pool closed');
     }
 }
diff --git a/src/pipeline/services/prompt-engine.ts b/src/pipeline/services/prompt-engine.ts
index aa3af0f..c614365 100644
--- a/src/pipeline/services/prompt-engine.ts
+++ b/src/pipeline/services/prompt-engine.ts
@@ -16,7 +16,7 @@ export const buildCinematicPrompt = (
   if (scene.mood) parts.push(`Mood: ${scene.mood}`);
 
   // 2. Location
-  parts.push(`Location: ${location.name}. ${location.lightingConditions.hardness} lighting.`);
+  parts.push(`Location: ${location.name}. ${location.lightingConditions.quality.Hardness} lighting.`);
   if (location.weather) parts.push(`Weather: ${location.weather}`);
   if (location.timeOfDay) parts.push(`Time: ${location.timeOfDay}`);
 
@@ -36,11 +36,11 @@ export const buildCinematicPrompt = (
   if (cinematography.composition) parts.push(`Composition: ${cinematography.composition}`);
 
   // 5. Lighting Details
-  if (lighting.motivatedSources.length > 0) {
-    parts.push(`Lighting Sources: ${lighting.motivatedSources.join(", ")}`);
+  if (Object.values(lighting.motivatedSources).length > 0) {
+    parts.push(`Lighting Sources: ${Object.values(lighting.motivatedSources).join(", ")}`);
   }
-  if (lighting.colorTemperature) {
-    parts.push(`Color Temp: ${lighting.colorTemperature}`);
+  if (lighting.quality.colorTemperature) {
+    parts.push(`Color Temp: ${lighting.quality.colorTemperature}`);
   }
 
   return parts.join("\n");
diff --git a/src/pipeline/services/workflow-service.ts b/src/pipeline/services/workflow-service.ts
index df43a71..a12ca30 100644
--- a/src/pipeline/services/workflow-service.ts
+++ b/src/pipeline/services/workflow-service.ts
@@ -13,6 +13,7 @@ import { mergeParamsIntoState, getAllBestFromAssets } from "../../shared/utils/u
 import { imageModelName, qualityCheckModelName, textModelName, videoModelName } from "../../workflow/llm/google/models";
 import { AssetVersionManager } from "../../workflow/asset-version-manager";
 import { DistributedLockManager } from "./lock-manager";
+import { JobRecordFrameRender } from "@shared/types/job.types";
 
 
 
@@ -32,8 +33,8 @@ export class WorkflowOperator {
         publishEvent: (event: PipelineEvent) => Promise<void>,
         projectRepository: ProjectRepository,
         lockManager: DistributedLockManager,
-        gcpProjectId?: string,
-        bucketName?: string
+        gcpProjectId: string,
+        bucketName: string
     ) {
         this.checkpointerManager = checkpointerManager;
         this.controlPlane = controlPlane;
@@ -41,11 +42,8 @@ export class WorkflowOperator {
         this.projectRepository = projectRepository;
         this.lockManager = lockManager;
 
-        this.gcpProjectId = gcpProjectId || process.env.GCP_PROJECT_ID!;
-        this.bucketName = bucketName || process.env.GCP_BUCKET_NAME!;
-        if (!this.bucketName) {
-            throw new Error("GCP_BUCKET_NAME environment variable not set.");
-        }
+        this.gcpProjectId = gcpProjectId;
+        this.bucketName = bucketName;
     }
 
     public getAbortController(projectId: string): AbortController {
@@ -152,16 +150,8 @@ export class WorkflowOperator {
             const existingCheckpoint = await this.checkpointerManager.loadCheckpoint(config);
             if (!existingCheckpoint) {
                 console.warn(`[WorkflowOperator] No checkpoint found to resume for ${projectId}`);
-                await this.publishEvent({
-                    type: "WORKFLOW_FAILED",
-                    commandId: uuidv7(),
-                    projectId: projectId,
-                    payload: { error: "No existing pipeline found to resume." },
-                    timestamp: new Date().toISOString(),
-                });
-                return;
             }
-            // const command = new Command({ resume: updatedState });
+
             const compiledGraph = await this.getCompiledGraph(projectId, this.getAbortController(projectId));
             await streamWithInterruptHandling(projectId, compiledGraph, null, config, "resumePipeline", this.publishEvent);
         });
@@ -174,11 +164,8 @@ export class WorkflowOperator {
             const existingCheckpoint = await this.checkpointerManager.loadCheckpoint(config);
             if (!existingCheckpoint) {
                 console.warn(`[WorkflowOperator.regenerateScene] No checkpoint found to regenerate scene ${sceneId}`);
-                return;
             }
 
-            const assetManager = new AssetVersionManager(this.projectRepository);
-            await assetManager.createVersionedAssets({ projectId, }, "scene_prompt", 'text', [ promptModification ], { model: textModelName });
             const project = await this.projectRepository.getProject(projectId);
             project.forceRegenerateSceneIds.push(sceneId);
 
@@ -186,7 +173,7 @@ export class WorkflowOperator {
             const compiled = await this.getCompiledGraph(projectId, this.getAbortController(projectId));
             const command = new Command({
                 goto: "process_scene",
-                update: updated
+                update: { project: updated }
             });
             await streamWithInterruptHandling(projectId, compiled, command, config, "regenerateScene", this.publishEvent);
         });
@@ -335,7 +322,8 @@ export class WorkflowOperator {
                 previousAssets[ "scene_end_frame" ]?.data
                 : previousAssets[ "scene_start_frame" ]?.data;
 
-        const jobPayload = {
+        const assetKey = frameType === 'start' ? "scene_start_frame" : "scene_end_frame";
+        const jobPayload: JobRecordFrameRender['payload'] = {
             scene,
             prompt: promptModification,
             framePosition: frameType,
@@ -346,18 +334,16 @@ export class WorkflowOperator {
                 ...sceneCharacterImages,
                 ...sceneLocationImages,
             ],
-            sceneId,
-            frameType,
-            promptModification
         };
-        const job = await this.controlPlane.createJob({
-            id: uuidv7(),
+
+
+        await this.controlPlane.createJob({
             type: "FRAME_RENDER",
+            assetKey: assetKey,
             projectId: projectId,
             payload: jobPayload,
             maxRetries: 3
         });
-        console.log(`[WorkflowOperator] Dispatched job ${job.id} for frame regeneration. Worker will process asynchronously.`);
     }
 
     async getProjectState(projectId: string) {
diff --git a/src/pipeline/workers/metrics-worker.ts b/src/pipeline/workers/metrics-worker.ts
index 72e9d1f..47d4569 100644
--- a/src/pipeline/workers/metrics-worker.ts
+++ b/src/pipeline/workers/metrics-worker.ts
@@ -1,5 +1,5 @@
 import { db } from "../../shared/db";
-import { projects, scenes } from "../../shared/schema";
+import { projects, scenes } from "../../shared/db/schema";
 import { eq, asc } from "drizzle-orm";
 import { predictRemainingAttempts, calculateTrend } from "../../shared/utils/regression";
 import { WorkflowMetrics } from "../../shared/types/pipeline.types";
diff --git a/src/server/index.ts b/src/server/index.ts
index 8d32fdd..0172e68 100644
--- a/src/server/index.ts
+++ b/src/server/index.ts
@@ -5,16 +5,14 @@ import { createServer } from "http";
 import { Storage } from "@google-cloud/storage";
 import * as dotenv from "dotenv";
 
-import { formatLoggers, logContextStore } from "@shared/format-loggers";
+import { initLogger, logContextStore } from "@shared/logger";
 import { contextMiddleware } from "./middle/context-handler";
 
 
 
 dotenv.config();
 
-formatLoggers(
-  { getStore: logContextStore.getStore.bind(logContextStore) },
-);
+initLogger();
 
 const app = express();
 const httpServer = createServer(app);
@@ -92,18 +90,18 @@ app.use((req, res, next) => {
         host: "0.0.0.0",
       },
       () => {
-        console.log(`serving on port ${port}`);
+        console.log(`Serving port ${port}`);
       },
     );
 
     if (import.meta.hot) {
       import.meta.hot.on("vite:beforeFullReload", () => {
-        console.log("Stopping server for reload...");
+        console.log("Reload");
         httpServer.close();
       });
 
       import.meta.hot.dispose(() => {
-        console.log("Disposing server...");
+        console.log("Closing...");
         httpServer.close();
       });
     }
diff --git a/src/server/middle/context-handler.ts b/src/server/middle/context-handler.ts
index 44da853..2638e89 100644
--- a/src/server/middle/context-handler.ts
+++ b/src/server/middle/context-handler.ts
@@ -1,12 +1,12 @@
 // src/middleware/context-handler.ts
-import { LogContext, logContextStore } from "../../shared/format-loggers";
+import { LogContext, logContextStore } from "../../shared/logger";
 import { serverId } from "../routes";
 
 export function contextMiddleware(req: any, res: any, next: () => void) {
     const context: LogContext = {
         correlationId: req.headers[ "x-correlation-id" ],
         projectId: req.headers[ "x-project-id" ],
-        workerId: `${process.env.HOSTNAME || 'express'}-${process.pid}`,
+        w_id: `${process.env.HOSTNAME || 'express'}-${process.pid}`,
         serverId,
         shouldPublishLog: false,
         method: req.method,
diff --git a/src/server/routes.ts b/src/server/routes.ts
index e3ab6cb..99813e3 100644
--- a/src/server/routes.ts
+++ b/src/server/routes.ts
@@ -90,7 +90,7 @@ export async function registerRoutes(
               case "FULL_STATE":
               case "INTERVENTION_RESOLVED":
               case "SCENE_STARTED":
-              case "SCENE_PROGRESS":
+              case "SCENE_UPDATE":
               case "SCENE_COMPLETED":
               case "SCENE_SKIPPED":
               case "WORKFLOW_STARTED":
diff --git a/src/server/tests/concurrency.test.ts b/src/server/tests/concurrency.test.ts
index 88e254f..72a9903 100644
--- a/src/server/tests/concurrency.test.ts
+++ b/src/server/tests/concurrency.test.ts
@@ -1,6 +1,5 @@
 import { describe, it, expect, vi, beforeEach } from 'vitest';
-import { LogContext, logContextStore } from '../../shared/format-loggers';
-import { formatLoggers } from '../../shared/format-loggers';
+import { LogContext, initLogger, logContextStore } from '../../shared/logger';
 
 describe('Concurrency & Context Integrity', () => {
     const mockPublish = vi.fn();
@@ -8,10 +7,7 @@ describe('Concurrency & Context Integrity', () => {
     beforeEach(() => {
         vi.clearAllMocks();
         // Initialize the interceptor
-        formatLoggers(
-            { getStore: logContextStore.getStore.bind(logContextStore) },
-            mockPublish
-        );
+        initLogger(mockPublish);
     });
 
     it('should maintain strict context isolation under high concurrency', async () => {
@@ -19,7 +15,7 @@ describe('Concurrency & Context Integrity', () => {
 
         const runTask = async (id: number) => {
             const context: LogContext = {
-                workerId: "test-worker",
+                w_id: "test-worker",
                 jobId: `job-${id}`,
                 projectId: `project-${id}`,
                 correlationId: `corr-${id}`,
diff --git a/src/shared/db.ts b/src/shared/db/index.ts
similarity index 100%
rename from src/shared/db.ts
rename to src/shared/db/index.ts
diff --git a/src/shared/schema.ts b/src/shared/db/schema.ts
similarity index 94%
rename from src/shared/schema.ts
rename to src/shared/db/schema.ts
index 725742e..4106489 100644
--- a/src/shared/schema.ts
+++ b/src/shared/db/schema.ts
@@ -7,8 +7,9 @@ import {
   InitialProjectMetadata, AssetRegistry, Lighting, Cinematography,
   CharacterState, LocationState, PhysicalTraits, WorkflowMetrics,
   InitialStoryboard,
-} from "./types/workflow.types";
-import { v7 as uuidv7 } from "uuid"; 
+  createDefaultMetrics,
+} from "../types/workflow.types";
+import { v7 as uuidv7 } from "uuid";
 import { sql } from "drizzle-orm";
 
 // --- ENUMS ---
@@ -46,20 +47,7 @@ export const projects = pgTable("projects", {
   generationRules: text("generation_rules").array().default([]).notNull(),
   generationRulesHistory: text("generation_rules_history").array().array().default([]).notNull(),
 
-  metrics: jsonb("metrics").$type<WorkflowMetrics>().default({
-    sceneMetrics: {},
-    versionMetrics: {},
-    trendHistory: [],
-    regression: {
-      count: 0,
-      sumX: 0,
-      sumY_a: 0,
-      sumY_q: 0,
-      sumXY_a: 0,
-      sumXY_q: 0,
-      sumX2: 0,
-    },
-  }).notNull(),
+  metrics: jsonb("metrics").$type<WorkflowMetrics>().default(createDefaultMetrics()).notNull(),
 });
 
 export const characters = pgTable("characters", {
@@ -91,7 +79,7 @@ export const locations = pgTable("locations", {
   weather: text("weather").notNull(),
   colorPalette: jsonb("color_palette").$type<string[]>().notNull(),
   mood: text("mood").notNull(),
-  
+
   architecture: text("architecture").notNull(),
   naturalElements: jsonb("natural_elements").$type<string[]>().notNull(),
   manMadeObjects: jsonb("man_made_objects").$type<string[]>().notNull(),
@@ -138,7 +126,7 @@ export const jobs = pgTable("jobs", {
   result: jsonb("result"),
   error: text("error"),
   uniqueKey: text("unique_key"),
-  assetKey: text("asset_key"), 
+  assetKey: text("asset_key"),
   attempt: integer("attempt").default(1).notNull(),
   maxRetries: integer("max_retries").default(4).notNull(), // Default (3) + 1st attempt
 
diff --git a/src/shared/zod-db.ts b/src/shared/db/zod-db.ts
similarity index 98%
rename from src/shared/zod-db.ts
rename to src/shared/db/zod-db.ts
index d154d38..78c35bf 100644
--- a/src/shared/zod-db.ts
+++ b/src/shared/db/zod-db.ts
@@ -13,7 +13,7 @@ import {
   LocationStateSchema,
   InitialProjectSchema,
   LocationSchema
-} from "./types/workflow.types";
+} from "../types/workflow.types";
 
 // --- PROJECT HELPERS ---
 export const DbProjectSchema = createSelectSchema(dbSchema.projects);
diff --git a/src/shared/format-loggers.ts b/src/shared/format-loggers.ts
deleted file mode 100644
index d306255..0000000
--- a/src/shared/format-loggers.ts
+++ /dev/null
@@ -1,69 +0,0 @@
-import { logger, LogContext } from './logger';
-import { format } from 'util';
-import os from 'os';
-import { AsyncLocalStorage } from 'async_hooks';
-
-
-
-export { LogContext };
-export const logContextStore = new AsyncLocalStorage<LogContext>();
-
-// Helper to determine if a log is marked as internal-only
-const isInternalLog = (args: any[]) =>
-    args.some(arg => typeof arg === 'string' && arg.includes("LOG_INTERNAL_ONLY"));
-
-export function formatLoggers(
-    store: { getStore: () => LogContext | undefined; },
-    publishPipelineEvent?: (event: any) => Promise<void>
-) {
-    const handleIntercept = async (level: string, args: any[]) => {
-        const context = store.getStore();
-
-        // 1. Format the human-readable message string (handles %s, %d, etc.)
-        const message = format(...args);
-
-        // 2. Extract any objects from args to merge into the JSON structure
-        //    (This allows console.log("Event", { userId: 1 }) to structure 'userId')
-        const objectArgs = args.find(arg => typeof arg === 'object' && arg !== null) || {};
-
-        // 3. Log locally using Pino (Structured)
-        //    We merge context first, then object args, then the readable message
-        (logger as any)[ level ]({ ...context, ...objectArgs }, message);
-
-        // 4. Determine if we should publish to the Pipeline
-        //    DEFAULT: Publish UNLESS explicitly disabled in context OR marked internal
-        const shouldPublishLog =
-            context &&
-            context.projectId &&
-            (context.shouldPublishLog !== false || !isInternalLog(args)) &&
-            publishPipelineEvent;
-
-        if (shouldPublishLog) {
-            publishPipelineEvent({
-                type: "LOG",
-                projectId: context.projectId,
-                correlationId: context.correlationId,
-                timestamp: new Date().toISOString(),
-                payload: {
-                    level,
-                    message, // The clean, formatted string
-                    job_id: context.jobId,
-                    worker_id: context.workerId,
-                    server_id: context.serverId,
-                    hostname: os.hostname(),
-                    process_id: process.pid,
-                    // If you really want raw args dump, put it in a specific field
-                    // raw_args: args 
-                },
-            }).catch(err => {
-                // Use a string flag to prevent infinite recursion
-                logger.error({ err, internal: true }, "LOG_INTERNAL_ONLY: Failed to publish pipeline event");
-            });
-        }
-    };
-
-    // Monkey-patch console methods
-    console.log = (...args) => handleIntercept('info', args);
-    console.warn = (...args) => handleIntercept('warn', args);
-    console.error = (...args) => handleIntercept('error', args);
-}
\ No newline at end of file
diff --git a/src/shared/logger.ts b/src/shared/logger.ts
deleted file mode 100644
index 8e84a81..0000000
--- a/src/shared/logger.ts
+++ /dev/null
@@ -1,44 +0,0 @@
-import pino from 'pino';
-import os from 'os';
-
-
-
-export interface LogContext {
-    commandId?: string;
-    jobId?: string;
-    projectId?: string;
-    workerId: string;
-    serverId?: string;
-    correlationId: string;
-    shouldPublishLog: boolean;
-    [ key: string ]: any;
-}
-
-const isDev = process.env.NODE_ENV !== 'production';
-
-export const logger = pino({
-    level: process.env.LOG_LEVEL || 'info',
-    // Mix in global worker context to every log
-    mixin() {
-        return { worker_id: `${os.hostname()}-${process.pid}`.toLowerCase() };
-    },
-    formatters: {
-        level: (label) => ({ level: label.toUpperCase() }),
-    },
-    // Add human-readable timestamps for machine logs too
-    base: undefined, // Removes pid/hostname from default to use our mixin format
-    timestamp: () => `,"timestamp_iso":"${new Date().toISOString()}","timestamp_human":"${new Date().toLocaleString()}"`,
-    transport: isDev ? {
-        target: 'pino-pretty',
-        options: { colorize: true, translateTime: 'SYS:standard' }
-    } : undefined,
-});
-
-/**
- * Creates a scoped logger for a specific job or project.
- * This ensures every log line within a job execution automatically 
- * includes the IDs without re-typing them.
- */
-export function createJobLogger(context: LogContext) {
-    return logger.child(context);
-}
\ No newline at end of file
diff --git a/src/shared/logger/index.ts b/src/shared/logger/index.ts
new file mode 100644
index 0000000..f9e7e37
--- /dev/null
+++ b/src/shared/logger/index.ts
@@ -0,0 +1,2 @@
+export { logger } from './logger';
+export * from './init-logger';
\ No newline at end of file
diff --git a/src/shared/logger/init-logger.ts b/src/shared/logger/init-logger.ts
new file mode 100644
index 0000000..3acfcb2
--- /dev/null
+++ b/src/shared/logger/init-logger.ts
@@ -0,0 +1,47 @@
+import { logger } from './logger';
+import { LogContext } from './log-context';
+import { format } from 'util';
+import os from 'os';
+import { AsyncLocalStorage } from 'async_hooks';
+
+
+
+export { LogContext };
+export const logContextStore = new AsyncLocalStorage<LogContext>();
+
+export function initLogger(
+    publishPipelineEvent?: (event: any) => Promise<void>
+) {
+
+    const handleIntercept = async (level: 'info' | 'warn' | 'error', args: any[]) => {
+        const context = logContextStore.getStore();
+
+        const hasObject = typeof args[ 0 ] === 'object' && args[ 0 ] !== null;
+        const metadata = hasObject ? args[ 0 ] : {};
+        const messageArgs = hasObject ? args.slice(1) : args;
+        const message = format(...messageArgs);
+
+        const { shouldPublishLog, ...cleanContext } = context || {};
+
+        logger[ level ]({ ...cleanContext, ...metadata }, message);
+
+        if (shouldPublishLog === true && context && context.projectId && publishPipelineEvent) {
+            publishPipelineEvent({
+                type: "LOG",
+                projectId: context.projectId,
+                correlationId: context.correlationId,
+                payload: {
+                    level,
+                    message,
+                    job_id: context.jobId,
+                },
+            }).catch(err => {
+                logger.error({ err }, "Failed to publish log to pipeline");
+            });
+        }
+    };
+
+    console.log = (...args) => handleIntercept('info', args);
+    console.warn = (...args) => handleIntercept('warn', args);
+    console.error = (...args) => handleIntercept('error', args);
+}
\ No newline at end of file
diff --git a/src/shared/logger/log-context.ts b/src/shared/logger/log-context.ts
new file mode 100644
index 0000000..016fedc
--- /dev/null
+++ b/src/shared/logger/log-context.ts
@@ -0,0 +1,11 @@
+export interface LogContext {
+    commandId?: string;
+    jobId?: string;
+    projectId?: string;
+    w_id: string;
+    serverId?: string;
+    correlationId: string;
+    shouldPublishLog: boolean;
+    functionName?: string;
+    [ key: string ]: any;
+}
\ No newline at end of file
diff --git a/src/shared/logger/logger.ts b/src/shared/logger/logger.ts
new file mode 100644
index 0000000..1c52bee
--- /dev/null
+++ b/src/shared/logger/logger.ts
@@ -0,0 +1,26 @@
+import pino from 'pino';
+import os from 'os';
+
+
+
+const isDev = process.env.NODE_ENV !== 'production';
+const hostname = os.hostname().toLowerCase();
+const pid = process.pid;
+
+export const logger = pino({
+    level: process.env.LOG_LEVEL || 'info',
+    // Base identity
+    base: {
+        w_id: `${hostname}-${pid}`,
+    },
+    formatters: {
+        level: (label) => ({ level: label.toUpperCase() }),
+    },
+    timestamp: () => `,"ts_iso":"${new Date().toISOString()}","ts_human":"${new Date().toLocaleString()}"`,
+    transport: isDev ? {
+        target: 'pino-pretty',
+        options: {
+            colorize: true, translateTime: 'SYS:standard', ignore: 'w_id,env'
+        }
+    } : undefined,
+});
diff --git a/src/shared/types/job.types.ts b/src/shared/types/job.types.ts
index b39ced9..6f1a059 100644
--- a/src/shared/types/job.types.ts
+++ b/src/shared/types/job.types.ts
@@ -1,20 +1,7 @@
 //shared/job.types.ts
-import { AudioAnalysis, Character, GeneratedScene, Location, Project, QualityEvaluationResult, Scene, Storyboard } from "./workflow.types";
-
-// export type JobCommand =
-//     | CreateJobCommand
-//     | CancelJobCommand;
-
-// export type CreateJobCommand = PubSubMessage<
-//     "CREATE_JOB",
-//     JobRecord
-// >;
-// export type CancelJobCommand = PubSubMessage<
-//     "CANCEL_JOB",
-//     {
-//         id: string;
-//     }
-// >;
+import { AssetKey, AudioAnalysis, Character, Location, Project, QualityEvaluationResult, Scene, SceneGenerationResult, Storyboard } from "./workflow.types";
+
+
 
 export type JobType =
     | "EXPAND_CREATIVE_PROMPT"
@@ -50,16 +37,28 @@ export type JobRecord =
     | JobRecordStitchVideo
     | JobRecordFrameRender;
 
-// Updated JobRecordBase with correct conditional intersection
-type JobRecordBase<T extends JobType, R extends Record<string, any>, P = undefined> = {
+type JobRecordBase<T extends JobType, R, P = undefined> = R extends undefined ? {
     id: string;
     projectId: string;
     type: T;
     state: JobState;
-    result?: R;
     error?: string;
     uniqueKey?: string;
-    assetKey: string;
+    assetKey: AssetKey;
+    attempt: number;
+    maxRetries: number;
+    createdAt: Date;
+    updatedAt: Date;
+    payload: P;
+} : {
+    id: string;
+    projectId: string;
+    type: T;
+    state: JobState;
+    result: R;
+    error?: string;
+    uniqueKey?: string;
+    assetKey: AssetKey;
     attempt: number;
     maxRetries: number;
     createdAt: Date;
@@ -158,17 +157,12 @@ export type JobRecordGenerateSceneFrames = JobRecordBase<
 
 export type JobRecordGenerateSceneVideo = JobRecordBase<
     "GENERATE_SCENE_VIDEO",
-    {
-        scene: GeneratedScene;
-        evaluation: QualityEvaluationResult | null;
-        attempts: number;
-        acceptedAttempt: number;
-        finalScore: number;
-    },
+    SceneGenerationResult,
     {
         sceneId: string;
         sceneIndex: number;
         version: number;
+        overridePrompt: boolean;
     }
 >;
 
@@ -186,7 +180,8 @@ export type JobRecordStitchVideo = JobRecordBase<
 export type JobRecordFrameRender = JobRecordBase<
     "FRAME_RENDER",
     {
-        frame: string;
+        scene: Scene;
+        image: string;
     },
     {
         scene: Scene;
@@ -206,3 +201,14 @@ export type JobEvent =
     | { type: "JOB_COMPLETED"; jobId: string; }
     | { type: "JOB_FAILED"; jobId: string; error: string; }
     | { type: "JOB_CANCELLED"; jobId: string; };
+
+export type GenerativeResultEnvelope<T> = {
+    data: T;
+    metadata: {
+        model: string;
+        evaluation?: QualityEvaluationResult;
+        attempts: number;
+        acceptedAttempt: number;
+        warning?: string;
+    };
+};
\ No newline at end of file
diff --git a/src/shared/types/metrics.types.ts b/src/shared/types/metrics.types.ts
index a0dfc29..44f3f4a 100644
--- a/src/shared/types/metrics.types.ts
+++ b/src/shared/types/metrics.types.ts
@@ -1,5 +1,5 @@
 import { z } from "zod";
-import { QualityEvaluationResultSchema } from "./quality.types";
+import { PromptCorrectionSchema, QualityEvaluationResultSchema } from "./quality.types";
 
 
 
@@ -49,7 +49,8 @@ export const AssetVersionSchema = z.object({
   version: z.number(),
   data: z.string().describe("The content (text) or URI (file)"),
   type: AssetTypeSchema,
-  createdAt: z.string(),
+  createdAt: z.date()
+    .default(() => new Date()),
   metadata: z.object({
     evaluation: QualityEvaluationResultSchema.optional().describe("Quality evaluation result").nullable(),
     model: z.string().nonoptional().describe("AI model used for asset generation"),
@@ -119,17 +120,19 @@ export const SceneGenerationMetricsSchema = z.array(z.object({
 export type SceneGenerationMetrics = z.infer<typeof SceneGenerationMetricsSchema>;
 
 
-export const versionMetricSchema = z.object({
-  sceneId: z.string().describe("Scene ID"),
+export const VersionMetricSchema = z.object({
+  assetKey: AssetKeySchema,
   attemptNumber: z.number().describe("Job attempt (1, 2, 3...)"),
   assetVersion: z.number().describe("Which version was created"),
   finalScore: z.number().describe("Final quality score"),
   jobId: z.string().describe("Link to specific job"),
-  jobDuration: z.number().optional().describe("Duration of the job"),
+  startTime: z.number().describe("Start time of the job attempt"),
+  endTime: z.number().describe("End time of the job attempt"),
+  attemptDuration: z.number().describe("Duration of the job attempt"),
   ruleAdded: z.array(z.string()).describe("Rules added to the job"),
-  corrections: z.array(z.string()).describe("Corrections made to the job"),
+  corrections: z.array(PromptCorrectionSchema).describe("Corrections made to the prompt"),
 });
-export type VersionMetric = z.infer<typeof versionMetricSchema>;
+export type VersionMetric = z.infer<typeof VersionMetricSchema>;
 
 
 export const TrendSchema = z.object({
@@ -154,10 +157,9 @@ export type RegressionState = z.infer<typeof RegressionStateSchema>;
 
 export const WorkflowMetricsSchema = z.object({
   sceneMetrics: z.record(z.uuid({ "version": "v7" }), SceneGenerationMetricsSchema).default({}).describe("Production metrics for scene generation"),
-  versionMetrics: z.record(AssetKeySchema, z.array(versionMetricSchema)).refine(
-    (val) => Object.keys(val).every((key) => AssetKeySchema.safeParse(key).success),
-    { message: "Invalid AssetKey used in versionMetrics" }
-  ).default({} as any).describe("Production metrics for asset generation") as z.ZodType<Partial<Record<AssetKey, VersionMetric[]>>>,
+  versionMetrics: z.partialRecord(AssetKeySchema, z.array(VersionMetricSchema).default([]))
+    .refine((val) => Object.keys(val).every((key) => AssetKeySchema.safeParse(key).success), { message: "Invalid AssetKey used in versionMetrics" })
+    .default({}).describe("Production metrics for asset generation"),
   trendHistory: z.array(TrendSchema).default([]).describe("Production metrics for trend analysis"),
   regression: RegressionStateSchema.default({
     count: 0,
@@ -169,7 +171,8 @@ export const WorkflowMetricsSchema = z.object({
     sumX2: 0,
   }).describe("Production metrics for regression analysis"),
   globalTrend: TrendSchema.optional().describe("Production metrics for global trend analysis"),
-}).describe("Production metrics");
+}).catchall(z.any())
+  .describe("Production metrics");
 export type WorkflowMetrics = z.infer<typeof WorkflowMetricsSchema>;
 
 
diff --git a/src/shared/types/pipeline.types.ts b/src/shared/types/pipeline.types.ts
index d010e20..2b7d49b 100644
--- a/src/shared/types/pipeline.types.ts
+++ b/src/shared/types/pipeline.types.ts
@@ -121,7 +121,7 @@ export type FullStateEvent = PubSubMessage<"FULL_STATE", { project: Project | In
 
 export type SceneStartedEvent = PubSubMessage<"SCENE_STARTED", { scene: Scene; totalScenes: number; }>;
 
-export type SceneProgressEvent = PubSubMessage<"SCENE_PROGRESS", { scene: Scene; progress?: number; }>;
+export type SceneProgressEvent = PubSubMessage<"SCENE_UPDATE", { scene: Scene; progress?: number; }>;
 
 export type SceneCompletedEvent = PubSubMessage<"SCENE_COMPLETED", { scene: Scene; }>;
 
@@ -161,7 +161,7 @@ export interface PipelineMessage {
 export type PipelineStatus = "ready" | "analyzing" | "generating" | "evaluating" | "complete" | "error" | "paused";
 export type StatusType = PipelineStatus | AssetStatus | "PASS" | "MINOR_ISSUES" | "MAJOR_ISSUES" | "FAIL" | "ACCEPT" | "ACCEPT_WITH_NOTES" | "REGENERATE_MINOR" | "REGENERATE_MAJOR";
 
-export type OnGenerateCallbackArgs = [
+export type SaveAssetsCallbackArgs = [
     scope: Scope,
     assetKey: AssetKey,
     type: AssetType,
@@ -169,9 +169,13 @@ export type OnGenerateCallbackArgs = [
     metadata: Omit<AssetVersion[ 'metadata' ], 'jobId'>,
     setBest?: boolean,
 ];
-
-export type OnProgressCallback<T> = (artifact: T) => void;
-export type OnGenerateCallback = (...args: OnGenerateCallbackArgs) => void;
-export type OnCompleteCallback<T> = (artifact: T, attemptMetric?: Omit<VersionMetric, 'sceneId'>) => void;
+export type SaveAssetsCallback = (...args: SaveAssetsCallbackArgs) => void;
+export type UpdateSceneCallbackArgs = [
+    scene: Scene,
+    saveToDb?: boolean,
+];
+export type UpdateSceneCallback = (...args: UpdateSceneCallbackArgs) => void;
+export type GetAttemptMetricCallback = (attemptMetric: Pick<VersionMetric, "assetKey" | "finalScore" | "startTime" | "ruleAdded" | "attemptNumber" | "assetVersion" | "corrections">) => void;
+export type OnAttemptCallback = (attempt: number) => void;
 
 export * from './workflow.types.ts';
\ No newline at end of file
diff --git a/src/shared/types/quality.types.ts b/src/shared/types/quality.types.ts
index d4a3176..0db0a21 100644
--- a/src/shared/types/quality.types.ts
+++ b/src/shared/types/quality.types.ts
@@ -73,7 +73,8 @@ export const QualityEvaluationSchema = z.object({
 
 export const QualityEvaluationResultSchema = QualityEvaluationSchema.extend(
     z.object({
-        overall: z.enum([ "ACCEPT", "ACCEPT_WITH_NOTES", "REGENERATE_MINOR", "REGENERATE_MAJOR", "FAIL" ]),
+        grade: z.enum([ "ACCEPT", "ACCEPT_WITH_NOTES", "REGENERATE_MINOR", "REGENERATE_MAJOR", "FAIL" ]),
+        score: z.number().describe("Final quality score"),
     }).shape
 );
 export type QualityEvaluationResult = z.infer<typeof QualityEvaluationResultSchema>;
diff --git a/src/shared/types/workflow.types.ts b/src/shared/types/workflow.types.ts
index a095da4..5b28eff 100644
--- a/src/shared/types/workflow.types.ts
+++ b/src/shared/types/workflow.types.ts
@@ -2,11 +2,46 @@
 import { z } from "zod";
 import { CinematographySchema, LightingSchema, TransitionTypesSchema } from "./cinematography.types";
 import { AssetRegistrySchema, WorkflowMetricsSchema } from "./metrics.types";
-import { QualityEvaluationResult, QualityEvaluationResultSchema } from "./quality.types";
 
 
-
-export const getJsonSchema = (schema: z.ZodType) => z.toJSONSchema(schema, { target: "openapi-3.0" });
+/**
+ * Converts a Zod schema to a Draft 2020-12 JSON Schema compatible with Vertex AI.
+ * * @remarks
+ * This function includes specific overrides to prevent the "Too many states for serving" 
+ * error in Vertex AI by:
+ * 1. Mapping `z.date()` to simple ISO-8601 strings.
+ * 2. Stripping complex Regex patterns from UUIDs to simplify the Finite State Machine (FSM).
+ * 3. Providing a hook to simplify or omit high-complexity objects like `assets` or `evaluation`.
+ * * @param {z.ZodType} schema - The Zod schema to be converted.
+ * @returns {Record<string, any>} An OpenAPI/Vertex AI compatible JSON Schema object.
+ * * @example
+ * ```typescript
+ * const schema = z.object({ id: z.string().uuid() });
+ * const jsonSchema = getJsonSchema(schema);
+ * ```
+ */
+export const getJsonSchema = (schema: z.ZodType) => {
+  return z.toJSONSchema(schema, {
+    // Switching to openapi3 reduces meta-schema bloat
+    target: "openapi3",
+    unrepresentable: "any",
+    override: (ctx) => {
+      const zodSchema = ctx.zodSchema;
+
+      // Force Dates to simple strings
+      if (zodSchema instanceof z.ZodDate) {
+        return { type: "string", description: "ISO 8601 date-time" };
+      }
+
+      // Force UUIDs to simple strings (Strips the complex Regex)
+      if (zodSchema instanceof z.ZodUUID) {
+        return { type: "string", description: "UUID format" };
+      }
+
+      return undefined;
+    }
+  });
+};
 
 // ============================================================================
 // CONSTANTS
@@ -58,8 +93,10 @@ export type AudioAnalysis = z.infer<typeof AudioAnalysisSchema> & {
 export const TagSchema = z.object({
   id: z.uuid({ "version": "v7" }).nonempty().nonoptional().describe("unique identifier (uuid)"),
   projectId: z.uuid({ "version": "v7" }).nonempty().nonoptional().describe("Pipeline project id"),
-  createdAt: z.date().default(new Date()),
-  updatedAt: z.date().default(new Date()),
+  createdAt: z.date()
+    .default(() => new Date()),
+  updatedAt: z.date()
+    .default(() => new Date()),
 });
 export type Tag = z.infer<typeof TagSchema>;
 
@@ -106,7 +143,7 @@ export const SceneSchema = z.object({
   sceneIndex: z.number().describe("Index of the scene in the storyboard"),
   assets: AssetRegistrySchema,
 }).describe("Composition of all department specs + audio timing + generation outputs");
-export type Scene = z.infer<typeof SceneSchema>;
+export type Scene = z.infer<typeof SceneSchema>; 
 
 
 export interface SceneGenerationInput {
@@ -115,31 +152,12 @@ export interface SceneGenerationInput {
 }
 
 
-export type GeneratedScene = Scene & {
+export type SceneGenerationResult = {
+  scene: Scene;
   enhancedPrompt: string;
+  videoUrl: string;
 };
 
-
-export interface SceneGenerationResult {
-  scene: GeneratedScene;
-  videoUrl?: string;
-  attempts: number;
-  finalScore: number;
-  evaluation: QualityEvaluationResult | null;
-  warning?: string;
-  acceptedAttempt: number;
-}
-
-
-export interface FrameGenerationResult {
-  frame: string;
-  attempts: number;
-  finalScore: number;
-  evaluation: QualityEvaluationResult | null;
-  warning?: string;
-}
-
-
 export interface VideoGenerationConfig {
   resolution: "480p" | "720p" | "1080p";
   durationSeconds: 4 | 6 | 8;
@@ -224,10 +242,7 @@ export type ProjectMetadata = z.infer<typeof ProjectMetadataSchema>;
 
 export const PhysicalTraitsSchema = z.object({
   hair: z.string().describe("specific hairstyle, color, length, texture"),
-  clothing: z.union([
-    z.string(),
-    z.array(z.string())
-  ]).describe("specific outfit description (string or array of garments)"),
+  clothing: z.array(z.string()).describe("specific outfit description (string or array of garments)"),
   accessories: z.array(z.string()).describe("list of accessories").default([]),
   distinctiveFeatures: z.array(z.string()).describe("list of distinctive features").default([]),
   build: z.string().optional().describe("physical build description"),
@@ -426,8 +441,8 @@ export type Storyboard = z.infer<typeof StoryboardSchema>;
 
 export const InitialContextSchema = z.object({
   metadata: InitialProjectMetadataSchema,
-  characters: z.array(CharacterSchema),
-  locations: z.array(LocationSchema),
+  characters: z.array(CharacterSchema.omit({ assets: true, id: true, projectId: true, createdAt: true, updatedAt: true })),
+  locations: z.array(LocationSchema.omit({ assets: true, id: true, projectId: true, createdAt: true, updatedAt: true })),
 });
 
 
@@ -443,8 +458,10 @@ export const SceneBatchSchema = z.object({
  */
 export const InitialProjectSchema = z.object({
   id: z.uuid({ "version": "v7" }).nonempty().nonoptional().describe("unique identifier (uuid)"),
-  createdAt: z.date().default(new Date()),
-  updatedAt: z.date().default(new Date()),
+  createdAt: z.date()
+    .default(() => new Date()),
+  updatedAt: z.date()
+    .default(() => new Date()),
 
   // Loose storyboard and metadata
   storyboard: InitialStoryboardSchema.describe("The initial storyboard plan (empty at creation)"),
@@ -477,8 +494,10 @@ export type InitialProject = z.infer<typeof InitialProjectSchema>;
  */
 export const ProjectSchema = z.object({
   id: z.uuid({ "version": "v7" }).nonempty().nonoptional().describe("unique identifier (uuid)"),
-  createdAt: z.date().default(new Date()),
-  updatedAt: z.date().default(new Date()),
+  createdAt: z.date()
+    .default(() => new Date()),
+  updatedAt: z.date()
+    .default(() => new Date()),
 
   // Strict storyboard and metadata
   storyboard: StoryboardSchema.describe("The immutable storyboard snapshot"),
@@ -520,8 +539,10 @@ export const UserSchema = z.object({
   id: z.uuid({ "version": "v7" }),
   name: z.string(),
   email: z.email().optional(),
-  createdAt: z.string().default(new Date().toISOString()),
-  updatedAt: z.string().default(new Date().toISOString()),
+  createdAt: z.date()
+    .default(() => new Date()),
+  updatedAt: z.date()
+    .default(() => new Date()),
 });
 
 
diff --git a/src/shared/utils/llm-retry.ts b/src/shared/utils/llm-retry.ts
index 927dcd6..29a4ce8 100644
--- a/src/shared/utils/llm-retry.ts
+++ b/src/shared/utils/llm-retry.ts
@@ -31,7 +31,7 @@ const defaultRetryConfig = { initialDelay: 1000, backoffFactor: 2, };
  * @param onRetry - Optional callback to modify params or handle error before retry.
  * @returns The completion from the LLM call.
  */
-export async function retryLlmCall<T, U>(
+export async function retryLlmCall<U, T>(
     llmCall: (params: T) => Promise<U>,
     initialParams: T,
     config: RetryConfig,
@@ -44,48 +44,49 @@ export async function retryLlmCall<T, U>(
 
     while (attempt <= maxRetries) {
         try {
-            console.log(`Calling LLM (Attempt ${attempt})...`);
-            console.debug(`params `, { params: JSON.stringify(params, null, 2) });
+            console.log({ attempt, maxRetries, functionName: llmCall.name }, `Calling LLM (Attempt ${attempt})...`);
+            console.debug({ params: JSON.stringify(params, null, 2) });
             return await llmCall(params);
         } catch (error) {
 
             console.error('LLM call failed. Triggering graph interrupt for human intervention.Error: ', error);
-            const interruptValue: LlmRetryInterruptValue = {
-                nodeName: "",
-                type: "llm_intervention",
-                error: error instanceof Error ? error.message : String(error),
-                params: params as any,
-                attempt: attempt,
-                functionName: llmCall.name || "Unknown Function",
-                lastAttemptTimestamp: new Date().toISOString(),
-                projectId: retryConfig.projectId,
-            };
+            throw error;
+        //     const interruptValue: LlmRetryInterruptValue = {
+        //         nodeName: "",
+        //         type: "llm_intervention",
+        //         error: error instanceof Error ? error.message : String(error),
+        //         params: params as any,
+        //         attempt: attempt,
+        //         functionName: llmCall.name || "Unknown Function",
+        //         lastAttemptTimestamp: new Date().toISOString(),
+        //         projectId: retryConfig.projectId,
+        //     };
 
-            const resolution = interrupt(interruptValue);
-            if (resolution) {
-                if (resolution.action === 'cancel') {
-                    throw new Error('User cancelled operation.');
-                }
-                if (resolution.action === 'retry') {
-                    if (onRetry) {
-                        const { attempt: nextAttempt, params: nextParams } = await onRetry(error, attempt, params);
-                        attempt = nextAttempt;
-                        params = nextParams;
-                    }
-                    if (resolution.revisedParams) {
-                        params = resolution.revisedParams as T;
-                        console.debug('Resuming with revised params.');
-                    } else {
-                        console.debug('Resuming retry with original params.');
-                    }
-                    attempt++;
-                    console.log(`Waiting ${delay / 1000}s before retry.`);
-                    await new Promise(resolve => setTimeout(resolve, delay));
-                    delay *= retryConfig.backoffFactor;
+        //     const resolution = interrupt(interruptValue);
+        //     if (resolution) {
+        //         if (resolution.action === 'cancel') {
+        //             throw new Error('User cancelled operation.');
+        //         }
+        //         if (resolution.action === 'retry') {
+        //             if (onRetry) {
+        //                 const { attempt: nextAttempt, params: nextParams } = await onRetry(error, attempt, params);
+        //                 attempt = nextAttempt;
+        //                 params = nextParams;
+        //             }
+        //             if (resolution.revisedParams) {
+        //                 params = resolution.revisedParams as T;
+        //                 console.debug('Resuming with revised params.');
+        //             } else {
+        //                 console.debug('Resuming retry with original params.');
+        //             }
+        //             attempt++;
+        //             console.log(`Waiting ${delay / 1000}s before retry.`);
+        //             await new Promise(resolve => setTimeout(resolve, delay));
+        //             delay *= retryConfig.backoffFactor;
 
-                    continue;
-                }
-            }
+        //             continue;
+        //         }
+        //     }
         }
     }
 
diff --git a/src/shared/utils/pubsub-utils.ts b/src/shared/utils/pubsub-utils.ts
new file mode 100644
index 0000000..ab3946e
--- /dev/null
+++ b/src/shared/utils/pubsub-utils.ts
@@ -0,0 +1,32 @@
+import { CreateSubscriptionOptions, PubSub, Topic } from "@google-cloud/pubsub";
+
+/**
+ * Succinctly ensures a topic exists without throwing on ALREADY_EXISTS.
+ */
+export async function ensureTopic(pubsub: PubSub,topicName: string): Promise<Topic> {
+    const topic = pubsub.topic(topicName);
+    try {
+        await topic.create();
+    } catch (e: any) {
+        if (e.code !== 6) throw e;
+    }
+    console.log(`Ensuring topic ${topicName} exists...`);
+    return topic;
+}
+
+/**
+ * Succinctly ensures a subscription exists without throwing on ALREADY_EXISTS.
+ */
+export async function ensureSubscription(topic: Topic, name: string, options: CreateSubscriptionOptions = {}) {
+    try {
+        await topic.createSubscription(name, {
+            enableExactlyOnceDelivery: true,
+            ackDeadlineSeconds: 60,
+            expirationPolicy: { ttl: { seconds: 24 * 60 * 60 } },
+            ...options
+        });
+    } catch (e: any) {
+        if (e.code !== 6) throw e;
+    }
+    console.log(`Ensuring subscription ${name} exists on ${topic.name}...`);
+}
\ No newline at end of file
diff --git a/src/shared/utils/quality-retry-handler.ts b/src/shared/utils/quality-retry-handler.ts
index e4816f6..eb2c15f 100644
--- a/src/shared/utils/quality-retry-handler.ts
+++ b/src/shared/utils/quality-retry-handler.ts
@@ -4,10 +4,12 @@
  * Eliminates code duplication between frame and scene generation
  */
 
-import { OnCompleteCallback, OnProgressCallback } from "@shared/types/pipeline.types";
+import { GetAttemptMetricCallback } from "@shared/types/pipeline.types";
 import { QualityEvaluationResult, QualityConfig, Scene } from "../types/workflow.types";
 import { RetryLogger, RetryContext } from "./retry-logger";
 
+
+
 export interface QualityRetryConfig {
   qualityConfig: QualityConfig;
   context: RetryContext;
@@ -30,16 +32,14 @@ export interface QualityRetryResult<T> {
 export type GenerateCallbackProps<T> = [
   prompt: string,
   attempt: number,
-  onProgress?: OnProgressCallback<T>,
 ];
 export type EvaluateCallbackProps<T> = [
-  output: T, attempt: number, onProgress?: OnProgressCallback<T>
+  output: T, attempt: number
 ];
 export type ApplyCorrectionsCallbackProps<T> = [
   prompt: string,
   evaluation: QualityEvaluationResult,
   attempt: number,
-  onProgress?: OnProgressCallback<T>,
 ];
 export type CalculateScoreProps = [ evaluation: QualityEvaluationResult ];
 
@@ -48,8 +48,7 @@ export interface GenerationCallbacks<T> {
   evaluate: (...args: EvaluateCallbackProps<T>) => Promise<QualityEvaluationResult>;
   applyCorrections: (...args: ApplyCorrectionsCallbackProps<T>) => Promise<string>;
   calculateScore: (...args: CalculateScoreProps) => number;
-  onComplete?: OnCompleteCallback<T>;
-  onProgress?: OnProgressCallback<T>;
+  onComplete?: GetAttemptMetricCallback;
 }
 
 /**
@@ -70,7 +69,7 @@ export class QualityRetryHandler {
     const { qualityConfig, context } = config;
     const acceptanceThreshold = qualityConfig.minorIssueThreshold;
 
-    const { generate, evaluate, applyCorrections, calculateScore, onComplete, onProgress } = callbacks;
+    const { generate, evaluate, applyCorrections, calculateScore, onComplete } = callbacks;
 
     let bestOutput: T | null = null;
     let bestEvaluation: QualityEvaluationResult | null = null;
@@ -86,9 +85,9 @@ export class QualityRetryHandler {
 
         RetryLogger.logAttemptStart(attemptContext, currentPrompt.length);
 
-        const output = await generate(currentPrompt, attempt, onProgress);
+        const output = await generate(currentPrompt, attempt);
 
-        const evaluation = await evaluate(output, attempt, onProgress);
+        const evaluation = await evaluate(output, attempt);
         const score = calculateScore(evaluation);
         RetryLogger.logEvaluationDetails(attemptContext, evaluation, score);
 
@@ -102,12 +101,15 @@ export class QualityRetryHandler {
           console.log(`    Quality acceptable (${(score * 100).toFixed(1)}%)`);
           RetryLogger.logFinalResult(attemptContext, score, acceptanceThreshold, totalAttempts);
 
-          if (onComplete) {
-            onComplete(output, {
-              attemptNumber: attempt,
-              finalScore: bestScore,
-            });
-          }
+          // if (onComplete) {
+          //   onComplete(output, {
+          //     attemptNumber: attempt,
+          //     finalScore: bestScore,
+          //     ruleAdded: bestEvaluation?.promptCorrections?.map(c => c.correctedPromptSection)!,
+          //     assetVersion: attempt,
+          //     corrections: bestEvaluation?.promptCorrections!,
+          //   });
+          // }
           return {
             output,
             evaluation,
@@ -123,7 +125,7 @@ export class QualityRetryHandler {
         // Apply corrections for next attempt
         if (evaluation.promptCorrections && evaluation.promptCorrections.length > 0) {
           const originalLength = currentPrompt.length;
-          currentPrompt = await applyCorrections(currentPrompt, evaluation, attempt, onProgress);
+          currentPrompt = await applyCorrections(currentPrompt, evaluation, attempt);
           RetryLogger.logPromptCorrections(
             attemptContext,
             evaluation.promptCorrections,
diff --git a/src/shared/utils/retry-logger.ts b/src/shared/utils/retry-logger.ts
index dc34d18..7f6c788 100644
--- a/src/shared/utils/retry-logger.ts
+++ b/src/shared/utils/retry-logger.ts
@@ -43,7 +43,7 @@ export class RetryLogger {
     const icon = this.getScoreIcon(score);
 
     console.log(`\n EVALUATION RESULTS - Attempt ${context.attempt}`);
-    console.log(`   ${icon} Overall Score: ${scorePercent}% (${evaluation.overall})`);
+    console.log(`   ${icon} Overall Score: ${scorePercent}% (${evaluation.grade})`);
     console.log(`   ${''.repeat(60)}`);
 
     // Log dimension-by-dimension breakdown
diff --git a/src/shared/utils/utils.ts b/src/shared/utils/utils.ts
index e16826d..5ca87c5 100644
--- a/src/shared/utils/utils.ts
+++ b/src/shared/utils/utils.ts
@@ -1,4 +1,4 @@
-import { Character, Location, WorkflowMetrics, AttemptMetric, Trend, RegressionState, ValidDuration, VALID_DURATIONS, Storyboard, Project, WorkflowState, AssetRegistry, AssetKey, AssetType, AssetHistory, AssetVersion } from "../types/workflow.types";
+import { Character, Location, WorkflowMetrics, Trend, RegressionState, ValidDuration, VALID_DURATIONS, Storyboard, Project, WorkflowState, AssetRegistry, AssetKey, AssetType, AssetHistory, AssetVersion, VersionMetric } from "../types/workflow.types";
 
 /**
  * Sanitizes the storyboard by removing any potentially hallucinated asset URLs.
@@ -119,7 +119,8 @@ export function formatLocationSpecs(locations: Location[]): string {
  */
 export function calculateLearningTrends(
   currentMetrics: WorkflowMetrics,
-  newAttempt: AttemptMetric
+  assetKey: AssetKey,
+  newAttempt: VersionMetric
 ): WorkflowMetrics {
   // Clone to avoid mutation of the input if it's from state
   const metrics = { ...currentMetrics };
@@ -127,10 +128,10 @@ export function calculateLearningTrends(
   // Initialize defaults if missing (though types say they should be there)
   const regression = metrics.regression || { count: 0, sumX: 0, sumY_a: 0, sumY_q: 0, sumXY_a: 0, sumXY_q: 0, sumX2: 0 };
   const trendHistory = metrics.trendHistory ? [ ...metrics.trendHistory ] : [];
-  const attemptMetrics = metrics.attemptMetrics ? [ ...metrics.attemptMetrics ] : [];
+  const versionMetrics = metrics.versionMetrics || {};
 
-  // Add new attempt
-  attemptMetrics.push(newAttempt);
+  versionMetrics[ assetKey ] = versionMetrics[ assetKey ] || [];
+  versionMetrics[ assetKey ].push(newAttempt);
 
   // Update regression stats
   const n = regression.count + 1;
@@ -164,7 +165,7 @@ export function calculateLearningTrends(
 
   return {
     ...metrics,
-    attemptMetrics,
+    versionMetrics,
     trendHistory,
     regression: newRegression,
     globalTrend: newTrend,
@@ -174,7 +175,7 @@ export function calculateLearningTrends(
 export function mergeParamsIntoState(
   currentState: WorkflowState,
   params: Partial<WorkflowState>
-): Partial<Project> {
+): Partial<WorkflowState> {
   const updates: Partial<WorkflowState> = { ...currentState, ...params };
 
   // Merge scene prompt overrides
diff --git a/src/worker/index.ts b/src/worker/index.ts
index 9c90223..ace63f7 100644
--- a/src/worker/index.ts
+++ b/src/worker/index.ts
@@ -14,9 +14,9 @@ import { AsyncLocalStorage } from "async_hooks";
 import { v7 as uuidv7 } from 'uuid';
 import { WorkerService } from "./worker-service";
 import { DistributedLockManager } from "../pipeline/services/lock-manager";
-import { LogContext } from "../shared/logger";
 import * as dotenv from "dotenv";
-import { formatLoggers } from "../shared/format-loggers";
+import { initLogger, LogContext } from "../shared/logger/init-logger";
+import { ensureSubscription, ensureTopic } from "@shared/utils/pubsub-utils";
 dotenv.config();
 
 const logContextStore = new AsyncLocalStorage<LogContext>();
@@ -50,7 +50,7 @@ const jobEventsTopicPublisher = pubsub.topic(JOB_EVENTS_TOPIC_NAME);
 const videoEventsTopicPublisher = pubsub.topic(PIPELINE_EVENTS_TOPIC_NAME);
 
 async function publishJobEvent(event: JobEvent) {
-    console.log(`[Worker] Publishing job event ${event.type} to ${JOB_EVENTS_TOPIC_NAME}`);
+    console.log(`[Worker] Publishing job event ${event.type} to ${JOB_EVENTS_TOPIC_NAME}`, { event });
     const dataBuffer = Buffer.from(JSON.stringify(event));
     await jobEventsTopicPublisher.publishMessage({
         data: dataBuffer,
@@ -71,37 +71,26 @@ const jobControlPlane = new JobControlPlane(poolManager, publishJobEvent);
 const workerService = new WorkerService(gcpProjectId, workerId, bucketName, jobControlPlane, lockManager, publishJobEvent, publishPipelineEvent);
 
 const logContext: LogContext = {
-    workerId,
+    w_id: workerId,
     correlationId: uuidv7(),
     shouldPublishLog: false,
 };
 
 async function main() {
     console.log(`Starting generative worker service ${workerId}...`);
-    formatLoggers(
-        { getStore: logContextStore.getStore.bind(logContextStore) },
+    initLogger(
         publishPipelineEvent
     );
     await logContextStore.run(logContext, async () => {
         try {
+            // 1. Initialize Infrastructure
+            const jobEventsTopic = await ensureTopic(pubsub, JOB_EVENTS_TOPIC_NAME);
 
-            const [ topic ] = await pubsub.topic(JOB_EVENTS_TOPIC_NAME).get({ autoCreate: true });
-            const ensureSubscription = async (topic: any, subscriptionName: string, filter?: string) => {
-                console.log(`[Worker ${workerId}] Ensuring subscription ${subscriptionName} exists on ${topic.name}...`);
-                const isDev = process.env.NODE_ENV !== 'production';
-                try {
-                    await topic.createSubscription(subscriptionName, {
-                        enableExactlyOnceDelivery: true,
-                        ackDeadlineSeconds: 60, // Increased to 60s for stability
-                        expirationPolicy: { ttl: { seconds: 24 * 60 * 60 } }, 
-                        filter
-                    });
-                } catch (e: any) {
-                    if (e.code !== 6) throw e;
-                }
-            };
-            await ensureSubscription(topic, WORKER_JOB_EVENTS_SUBSCRIPTION, 'attributes.type = "JOB_DISPATCHED"');
+            await ensureSubscription(jobEventsTopic, WORKER_JOB_EVENTS_SUBSCRIPTION, {
+                filter: 'attributes.type = "JOB_DISPATCHED"'
+            });
 
+            // 2. Setup Consumer
             const subscription = pubsub.subscription(WORKER_JOB_EVENTS_SUBSCRIPTION);
             console.log(`[Worker ${workerId}] Listening on ${WORKER_JOB_EVENTS_SUBSCRIPTION}`);
 
@@ -118,27 +107,26 @@ async function main() {
 
                     if (event && event.type === "JOB_DISPATCHED") {
                         await logContextStore.run({ ...logContext, jobId: event.jobId, shouldPublishLog: false }, async () => {
-
                             console.log(`[Worker ${workerId}] Received JOB_DISPATCHED for ${event.jobId}`);
                             await workerService.processJob(event.jobId);
                         });
                     }
-                    await message.ackWithResponse(); // Using ackWithResponse for exactly-once
+                    await message.ackWithResponse(); 
                 } catch (error) {
                     console.error(`[Worker ${workerId}] Error processing message:`, error);
+                    message.nack();
                 }
             });
 
             // Handle shutdown
             process.on("SIGINT", async () => {
-                console.log("Shutting down worker...");
+                console.log("Shutting down worker");
                 subscription.close();
                 await poolManager.close();
                 process.exit(0);
             });
         } catch (error) {
             console.error(`[Worker ${workerId}] FATAL: PubSub initialization failed:`, error);
-            console.error(`[Worker ${workerId}] Service cannot start without PubSub. Shutting down...`);
             process.exit(1);
         }
     });
diff --git a/src/worker/worker-service.ts b/src/worker/worker-service.ts
index 474f2fe..5497134 100644
--- a/src/worker/worker-service.ts
+++ b/src/worker/worker-service.ts
@@ -1,5 +1,5 @@
 import { JobControlPlane } from "../pipeline/services/job-control-plane";
-import { JobEvent } from "../shared/types/job.types";
+import { GenerativeResultEnvelope, JobEvent, JobRecord, JobType } from "../shared/types/job.types";
 import { GCPStorageManager } from "../workflow/storage-manager";
 import { TextModelController } from "../workflow/llm/text-model-controller";
 import { VideoModelController } from "../workflow/llm/video-model-controller";
@@ -10,15 +10,16 @@ import { SemanticExpertAgent } from "../workflow/agents/semantic-expert-agent";
 import { FrameCompositionAgent } from "../workflow/agents/frame-composition-agent";
 import { SceneGeneratorAgent } from "../workflow/agents/scene-generator";
 import { ContinuityManagerAgent } from "../workflow/agents/continuity-manager";
-import { VersionMetric, Project, Scene, AssetVersion } from "../shared/types/workflow.types";
-import { deleteBogusUrlsStoryboard } from "../shared/utils/utils";
-import { OnGenerateCallback, OnProgressCallback, PipelineEvent } from "../shared/types/pipeline.types";
+import { VersionMetric, AssetVersion, Scene, Project } from "../shared/types/workflow.types";
+import { SaveAssetsCallback, PipelineEvent, UpdateSceneCallback, GetAttemptMetricCallback, OnAttemptCallback } from "../shared/types/pipeline.types";
 import { ProjectRepository } from "../pipeline/project-repository";
 import { MediaController } from "../workflow/media-controller";
 import { AssetVersionManager } from "../workflow/asset-version-manager";
-import { logContextStore } from "../shared/format-loggers";
+import { logContextStore } from "../shared/logger";
 import { DistributedLockManager } from "../pipeline/services/lock-manager";
 import { v7 as uuidv7 } from 'uuid';
+import { videoModelName } from "../workflow/llm/google/models";
+import { extractGenerationRules } from "src/workflow/prompts/prompt-composer";
 
 
 
@@ -93,28 +94,22 @@ export class WorkerService {
      */
     async processJob(jobId: string) {
 
-        const job = await this.jobControlPlane.claimJob(jobId);
-        if (!job) {
+        const claim = await this.jobControlPlane.claimJob(jobId);
+        if (!claim) {
             console.warn(`[Worker] Job ${jobId} unavailable or concurrency limit reached.`);
             return;
         }
 
-        const onProgress: OnProgressCallback<Scene> = async (scene) => {
-            console.log(`[Job ${jobId}] Progress: ${scene.progressMessage}`);
-            await this.publishPipelineEvent({
-                type: "SCENE_PROGRESS",
-                projectId: job.projectId,
-                payload: { scene },
-                timestamp: new Date().toISOString(),
-            });
-        };
+        const [ job, claimedAtISO ] = claim;
+        const startTime = new Date(claimedAtISO).getTime();
 
         await logContextStore.run({
             jobId: job.id,
+            jobUniqueKey: job.uniqueKey,
             projectId: job.projectId,
-            workerId: this.workerId,
+            w_id: this.workerId,
             correlationId: uuidv7(),
-            shouldPublishLog: true
+            shouldPublishLog: false
         }, async () => {
             try {
 
@@ -124,8 +119,38 @@ export class WorkerService {
                 const controller = new AbortController();
                 const agents = this.getAgents(job.projectId, controller.signal);
 
-                const onGenerate: OnGenerateCallback = async (...[ scope, assetKey, type, assets, metadata, setBest ]) => {
-                    agents.assetManager.createVersionedAssets(
+                const updateScene: UpdateSceneCallback = async (scene, saveToDb = true) => {
+                    console.log(`[Job ${jobId}] Progress: ${scene.progressMessage}`);
+                    if (saveToDb) this.projectRepository.updateScenes([ scene ]);
+
+                    this.publishPipelineEvent({
+                        type: "SCENE_UPDATE",
+                        projectId: job.projectId,
+                        payload: { scene },
+                        timestamp: new Date().toISOString(),
+                    });
+                };
+
+                const createIncrementer = (jobId: string): OnAttemptCallback => async (attempt: number) => {
+                    this.jobControlPlane.updateJobSafeAndIncrementAttempt(jobId, attempt);
+                };
+
+                const getAttemptMetric = (): GetAttemptMetricCallback => (attemptMetric): VersionMetric => {
+                    const endTime = Date.now();
+                    const attemptDuration = endTime - startTime;
+                    const versionMetric = {
+                        ...attemptMetric,
+                        endTime,
+                        attemptDuration,
+                        jobId,
+                    };
+                    return versionMetric;
+                    // save the metric here or after calling
+                };
+                const saveMetric = getAttemptMetric();
+
+                const saveAssets: SaveAssetsCallback = async (...[ scope, assetKey, type, assets, metadata, setBest ]) => {
+                    await agents.assetManager.createVersionedAssets(
                         scope,
                         assetKey,
                         type,
@@ -135,99 +160,196 @@ export class WorkerService {
                     );
                 };
 
+                type JobResultType<T extends JobType> = Extract<JobRecord, { type: T; }>[ 'result' ];
+
+                let data!: JobResultType<typeof job.type>;
+                let metadata: GenerativeResultEnvelope<typeof job.result>[ 'metadata' ];
 
-                let result = {} as typeof job.result;
-                let payload;
                 switch (job.type) {
                     case "EXPAND_CREATIVE_PROMPT": {
-                        payload = job.payload;
-                        const expanded = await agents.compositionalAgent.expandCreativePrompt(
-                            payload.title,
-                            payload.initialPrompt,
+
+                        let project = await this.projectRepository.getProject(job.projectId);
+
+                        ({ data, metadata } = await agents.compositionalAgent.expandCreativePrompt(
+                            job.payload.title,
+                            job.payload.initialPrompt,
                             { maxRetries: 3, attempt: 1, initialDelay: 1000, projectId: job.projectId }
-                        );
-                        result = { expandedPrompt: expanded };
+                        ));
+
+                             await this.projectRepository.updateInitialProject(project.id, {
+                            ...project,
+                            metadata: {
+                                ...project.metadata, enhancedPrompt: data.expandedPrompt,
+                            }
+                        });
+
+                        await this.jobControlPlane.updateJobSafe(jobId, job.attempt, { state: "COMPLETED", result: data });
+
                         break;
                     }
                     case "GENERATE_STORYBOARD": {
-                        payload = job.payload;
-                        let storyboard = await agents.compositionalAgent.generateStoryboardFromPrompt(
-                            payload.title,
-                            payload.enhancedPrompt,
-                            { attempt: job.attempt, maxRetries: job.maxRetries, projectId: job.projectId }
-                        );
-                        result = { storyboard: deleteBogusUrlsStoryboard(storyboard) };
+
+                        let project = await this.projectRepository.getProject(job.projectId);
+
+                        ({ data, metadata } = await agents.compositionalAgent.generateStoryboardFromPrompt(
+                            job.payload.title,
+                            job.payload.enhancedPrompt,
+                            { attempt: job.attempt, maxRetries: job.maxRetries, projectId: job.projectId },
+                            saveAssets
+                        ));
+
+                        await this.projectRepository.createScenes(project.id, data.storyboard.scenes);
+                        await this.projectRepository.createCharacters(project.id, data.storyboard.characters);
+                        await this.projectRepository.createLocations(project.id, data.storyboard.locations);
+
+                        await this.projectRepository.updateInitialProject(project.id, { storyboard: data.storyboard });
+
+                        await this.jobControlPlane.updateJobSafe(jobId, job.attempt, { state: "COMPLETED", result: data });
+
                         break;
                     }
+
                     case "PROCESS_AUDIO_TO_SCENES": {
-                        payload = job.payload;
-                        const analysis = await agents.audioProcessingAgent.processAudioToScenes(
+
+                        let project = await this.projectRepository.getProject(job.projectId);
+
+                        ({ data, metadata } = await agents.audioProcessingAgent.processAudioToScenes(
                             job.payload.audioPublicUri,
-                            payload.enhancedPrompt,
-                        );
-                        result = { analysis };
+                            job.payload.enhancedPrompt,
+                        ));
+
+                        const { segments, ...analysisData } = data.analysis;
+
+
+                        const projetMetadata = {
+                            ...project.metadata,
+                            ...analysisData,
+                        };
+
+                        project = {
+                            ...project,
+                            status: "pending",
+                            metadata: projetMetadata,
+                            scenes: segments as Scene[],
+                            characters: [],
+                            locations: [],
+                            storyboard: {
+                                metadata: projetMetadata,
+                                scenes: segments as Scene[],
+                                characters: [],
+                                locations: [],
+                            },
+                        } as Project;
+
+                        await this.projectRepository.updateInitialProject(job.projectId, project);
+
+                        await this.jobControlPlane.updateJobSafe(jobId, job.attempt, { state: "COMPLETED", result: data });
+
                         break;
                     }
                     case "ENHANCE_STORYBOARD": {
-                        payload = job.payload;
-                        const storyboard = await agents.compositionalAgent.generateFullStoryboard(
-                            payload.storyboard,
-                            payload.enhancedPrompt,
-                            { initialDelay: 30000, attempt: job.attempt, maxRetries: job.maxRetries, projectId: job.projectId }
-                        );
-                        result = { storyboard };
+
+                        let project = await this.projectRepository.getProject(job.projectId);
+
+                        ({ data, metadata } = await agents.compositionalAgent.generateFullStoryboard(
+                            job.payload.storyboard,
+                            job.payload.enhancedPrompt,
+                            { initialDelay: 30000, attempt: job.attempt, maxRetries: job.maxRetries, projectId: job.projectId },
+                            saveAssets,
+                        ));
+
+                        await this.projectRepository.createScenes(project.id, data.storyboard.scenes);
+                        await this.projectRepository.createCharacters(project.id, data.storyboard.characters);
+                        await this.projectRepository.createLocations(project.id, data.storyboard.locations);
+
+                        project = {
+                            ...project,
+                            status: "pending",
+                            storyboard: data.storyboard,
+                            metadata: data.storyboard.metadata,
+                            scenes: data.storyboard.scenes,
+                            characters: data.storyboard.characters,
+                            locations: data.storyboard.locations,
+                        } as Project;
+
+                        await this.projectRepository.updateProject(job.projectId, project);
+
+                        await this.jobControlPlane.updateJobSafe(jobId, job.attempt, { state: "COMPLETED", result: data });
+
                         break;
                     }
                     case "SEMANTIC_ANALYSIS": {
                         const project = await this.projectRepository.getProjectFullState(job.projectId);
-                        const dynamicRules = await agents.semanticExpert.generateRules(project.storyboard);
-                        result = { dynamicRules };
+
+                        ({ data, metadata } = await agents.semanticExpert.generateRules(project.storyboard));
+
+                        const proactiveRules = (await import("../workflow/prompts/generation-rules-presets")).getProactiveRules();
+                        const uniqueRules = Array.from(new Set([ ...proactiveRules, ...data.dynamicRules ]));
+
+                        project.generationRules = uniqueRules;
+                        project.generationRulesHistory.push(uniqueRules);
+
+                        await this.projectRepository.updateProject(job.projectId, project);
+
+                        await this.jobControlPlane.updateJobSafe(jobId, job.attempt, { state: "COMPLETED", result: data });
+
                         break;
                     }
                     case "GENERATE_CHARACTER_ASSETS": {
-                        payload = job.payload;
-                        const characters = await agents.continuityAgent.generateCharacterAssets(
-                            payload.characters,
-                            payload.generationRules,
-                            onGenerate,
-                            onProgress
-                        );
-                        result = { characters };
+
+                        ({ data, metadata } = await agents.continuityAgent.generateCharacterAssets(
+                            job.payload.characters,
+                            job.payload.generationRules,
+                            saveAssets,
+                            createIncrementer(jobId),
+                        ));
+
+                        await this.projectRepository.updateCharacters(data.characters);
+
+                        await this.jobControlPlane.updateJobSafe(jobId, job.attempt, { state: "COMPLETED", result: data });
+
                         break;
                     }
+
                     case "GENERATE_LOCATION_ASSETS": {
                         const locations = await this.projectRepository.getProjectLocations(job.projectId);
-                        const project = await this.projectRepository.getProject(job.projectId);
 
-                        const updatedLocations = await agents.continuityAgent.generateLocationAssets(
+                        ({ data, metadata } = await agents.continuityAgent.generateLocationAssets(
                             locations,
-                            project.generationRules,
-                            onGenerate,
-                            onProgress
-                        );
-                        result = { locations: updatedLocations };
+                            job.payload.generationRules,
+                            saveAssets,
+                            createIncrementer(jobId),
+                        ));
+
+                        await this.projectRepository.updateLocations(data.locations);
+
+                        await this.jobControlPlane.updateJobSafe(jobId, job.attempt, { state: "COMPLETED", result: data });
+
                         break;
                     }
+
                     case "GENERATE_SCENE_FRAMES": {
-                        payload = job.payload;
                         const project = await this.projectRepository.getProjectFullState(job.projectId);
 
-                        // TODO Check job end for write op, possibly impl a callback for writes
-                        const updatedScenes = await agents.continuityAgent.generateSceneFramesBatch(
+                        ({ data, metadata } = await agents.continuityAgent.generateSceneFramesBatch(
                             project,
                             job.assetKey as 'scene_start_frame' | 'scene_end_frame',
-                            onGenerate,
-                            onProgress
-                        );
-                        result = { updatedScenes };
+                            saveAssets,
+                            updateScene,
+                            createIncrementer(jobId),
+                        ));
+
+                        await this.projectRepository.updateProject(job.projectId, project);
+
+                        await this.jobControlPlane.updateJobSafe(jobId, job.attempt, { state: "COMPLETED", result: data });
+
                         break;
                     }
 
-                    // TODO Clear promptoverride after successful job
                     case "GENERATE_SCENE_VIDEO": {
-                        payload = job.payload;
+
                         const project = await this.projectRepository.getProjectFullState(job.projectId);
-                        const scene = project.scenes[ payload.sceneIndex ];
+                        const scene = project.scenes[ job.payload.sceneIndex ];
                         const generateAudio = project.metadata.hasAudio;
 
                         const {
@@ -238,54 +360,75 @@ export class WorkerService {
                             location,
                             previousScene,
                             generationRules,
-                        } = await agents.continuityAgent.prepareAndRefineSceneInputs(scene, project, false, onGenerate);
-
-                        const onComplete = (_scene: Scene, _attemptMetric: Omit<VersionMetric, 'sceneId'>) => {
-                            const attemptMetric: VersionMetric = {
-                                ..._attemptMetric,
-                                sceneId: _scene.id,
-                            };
-                            console.log(`[Job ${jobId}] complete:`, attemptMetric);
-                            this.projectRepository.updateScenes([ _scene ]);
-                        };
+                        } = await agents.continuityAgent.prepareAndRefineSceneInputs(scene, project, job.payload.overridePrompt, saveAssets);
 
                         const assets = scene.assets;
                         const startFrame = assets[ 'scene_start_frame' ]!.versions[ assets[ 'scene_start_frame' ]!.best ].data;
                         const endFrame = assets[ 'scene_end_frame' ]!.versions[ assets[ 'scene_end_frame' ]!.best ].data;
-                        result = await agents.sceneAgent.generateSceneWithQualityCheck({
+
+                        const { data, metadata } = await agents.sceneAgent.generateSceneWithQualityCheck({
                             scene,
                             enhancedPrompt,
                             sceneCharacters,
                             sceneLocation: location,
                             previousScene,
-                            version: payload.version,
+                            version: job.payload.version,
                             startFrame: startFrame,
                             endFrame: endFrame,
                             characterReferenceImages,
                             locationReferenceImages,
                             generateAudio,
-                            onComplete,
-                            onProgress,
+                            saveAssets,
+                            updateScene,
+                            onAttempt: createIncrementer(jobId),
+                            saveMetric,
                             generationRules
                         });
+
+                        const updatedProject = agents.continuityAgent.updateNarrativeState(data.scene, project);
+
+                        if (metadata.evaluation) {
+                            updatedProject.generationRules = Array.from(new Set(...updatedProject.generationRules, ...extractGenerationRules([ metadata.evaluation ])));
+                        }
+
+                        const forceRegenerateIndex = project?.forceRegenerateSceneIds.findIndex(id => id === scene.id);
+                        updatedProject.forceRegenerateSceneIds = project.forceRegenerateSceneIds.slice(0, forceRegenerateIndex).concat(project.forceRegenerateSceneIds.slice(forceRegenerateIndex + 1));
+
+                        await this.projectRepository.updateProject(job.projectId, updatedProject);
+
+                        await this.jobControlPlane.updateJobSafe(jobId, job.attempt, { state: "COMPLETED", result: data });
+
                         break;
                     }
-                    case "RENDER_VIDEO": {
-                        payload = job.payload;
 
+                    case "RENDER_VIDEO": {
                         let renderedVideo;
-                        if (payload.audioGcsUri) {
-                            renderedVideo = await agents.audioProcessingAgent.mediaController.stitchScenes(payload.videoPaths, job.projectId, job.attempt, payload.audioGcsUri);
+                        if (job.payload.audioGcsUri) {
+                            renderedVideo = await agents.audioProcessingAgent.mediaController.stitchScenes(job.payload.videoPaths, job.projectId, job.attempt, job.payload.audioGcsUri);
                         } else {
-                            renderedVideo = await agents.audioProcessingAgent.mediaController.stitchScenes(payload.videoPaths, job.projectId, job.attempt,);
+                            renderedVideo = await agents.audioProcessingAgent.mediaController.stitchScenes(job.payload.videoPaths, job.projectId, job.attempt);
                         }
-                        result = { renderedVideo };
+
+                        data = { renderedVideo };
+                        metadata = { model: videoModelName, attempts: 1, acceptedAttempt: 1 };
+
+                        saveAssets(
+                            { projectId: job.projectId },
+                            'render_video',
+                            'video',
+                            [ renderedVideo ],
+                            metadata,
+                        );
+
+                        await this.jobControlPlane.updateJobSafe(jobId, job.attempt, { state: "COMPLETED", result: data });
+
                         break;
                     }
+
                     case "FRAME_RENDER": {
-                        payload = job.payload;
+                        let payload = job.payload;
 
-                        const frame = await agents.frameCompositionAgent.generateImage(
+                        ({ data, metadata, } = await agents.frameCompositionAgent.generateImage(
                             payload.scene,
                             payload.prompt,
                             payload.framePosition,
@@ -293,25 +436,28 @@ export class WorkerService {
                             payload.sceneLocations,
                             payload.previousFrame,
                             payload.referenceImages,
-                            onGenerate,
-                            onProgress
-                        );
-                        result = { frame };
+                            saveAssets,
+                            updateScene,
+                            createIncrementer(jobId),
+                        ));
+
+                        await this.jobControlPlane.updateJobSafe(jobId, job.attempt, { state: "COMPLETED", result: data });
+
                         break;
                     }
                     default:
                         throw new Error(`Unknown job type: ${JSON.stringify(job)}`);
                 }
 
-                await this.jobControlPlane.updateJobSafe(jobId, job.attempt, { state: "COMPLETED", result });
-                await this.publishJobEvent({ type: "JOB_COMPLETED", jobId });
-                console.log(`[Worker ${this.workerId}] Job ${jobId} completed`);
+                const endTime = Date.now();
+                const durationMs = endTime - startTime;
+                this.publishJobEvent({ type: "JOB_COMPLETED", jobId });
 
-            } catch (error: any) {
-                console.error(`[Job ${jobId}] Execution failed:`, error);
-
-                await this.jobControlPlane.updateJobSafe(jobId, job.attempt, { state: "FAILED", error: error.message, attempt: job.attempt + 1 });
+                console.log(`[Worker ${this.workerId}] Job ${jobId} completed in ${durationMs}ms`);
 
+            } catch (error: any) {
+                console.error(`[Job ${jobId}] Execution failed:`, { error, job });
+                await this.jobControlPlane.updateJobSafeAndIncrementAttempt(jobId, job.attempt, { state: "FAILED", error: error.message, attempt: job.attempt + 1 });
                 await this.publishJobEvent({ type: "JOB_FAILED", jobId, error: error.message });
             }
         });
diff --git a/src/workflow/agents/audio-processing-agent.ts b/src/workflow/agents/audio-processing-agent.ts
index 9bf482a..8c4c21b 100644
--- a/src/workflow/agents/audio-processing-agent.ts
+++ b/src/workflow/agents/audio-processing-agent.ts
@@ -10,6 +10,8 @@ import { buildAudioProcessingInstruction } from "../prompts/audio-processing-ins
 import { TextModelController } from "../llm/text-model-controller";
 import { buildllmParams } from "../llm/google/google-llm-params";
 import { MediaController } from "../media-controller";
+import { GenerativeResultEnvelope, JobRecordProcessAudioToScenes } from "@shared/types/job.types";
+import { textModelName } from "../llm/google/models";
 
 export class AudioProcessingAgent {
     private llm: TextModelController;
@@ -30,54 +32,45 @@ export class AudioProcessingAgent {
      * @param enhancedPrompt The creative prompt for the video.
      * @returns A promise that resolves to an array of timed scenes and the audio GCS URI.
      */
-    async processAudioToScenes(audioPath: string | undefined, enhancedPrompt: string): Promise<AudioAnalysis> {
+    async processAudioToScenes(audioPath: string | undefined, enhancedPrompt: string): Promise<GenerativeResultEnvelope<JobRecordProcessAudioToScenes[ 'result' ]>> {
         if (!audioPath) {
             console.log(` No audio file provided, skipping audio processing`);
             return {
-                bpm: 0,
-                keySignature: '',
-                duration: 0,
-                segments: [],
-                audioGcsUri: '',
+                data: {
+                    analysis: {
+                        bpm: 0,
+                        keySignature: '',
+                        duration: 0,
+                        segments: [],
+                        audioGcsUri: '',
+                    }
+                },
+                metadata: {
+                    model: textModelName,
+                    attempts: 1,
+                    acceptedAttempt: 1,
+                }
             };
         }
 
         console.log(` Starting audio processing for: ${audioPath}`);
 
         const durationSeconds = await this.mediaController.getAudioDuration(audioPath);
-        console.log(`   ... Actual audio duration (ffprobe): ${durationSeconds}s`);
-
-        const audioGcsUri = this.storageManager.getGcsUrl(audioPath);
-        const audioPublicUri = this.storageManager.getPublicUrl(audioPath);
-
-        const result = await this.analyzeAudio(audioGcsUri, enhancedPrompt, durationSeconds);
-
-        if (!result?.candidates?.[ 0 ]?.content?.parts?.[ 0 ]?.text) {
-            throw Error("No valid analysis result from LLM");
-        }
-
-        const rawText = cleanJsonOutput(result.candidates[ 0 ].content.parts[ 0 ].text);
-        const analysis: AudioAnalysis = JSON.parse(rawText);
-        analysis.audioPublicUri = audioPublicUri;
 
-        // Initialize startFrame and endFrame for each scene
-        analysis.segments = analysis.segments.map((segment, index) => ({
-            ...segment,
-            sceneIndex: index, // Ensure 0-based sequential IDs
-            startFrame: undefined,
-            endFrame: undefined,
-        }));
+        const result = await this.analyzeAudio(audioPath, enhancedPrompt, durationSeconds);
 
-        console.log(`  Scene template generated with ${analysis.segments.length} scenes covering full track duration.`);
-        return analysis;
+        return result;
     }
 
-    private async analyzeAudio(gcsUri: string, userPrompt: string, durationSeconds: number): Promise<GenerateContentResponse> {
+    private async analyzeAudio(audioPath: string, userPrompt: string, durationSeconds: number): Promise<GenerativeResultEnvelope<JobRecordProcessAudioToScenes[ 'result' ]>> {
         console.log(`   ... Analyzing audio with Gemini (detailed musical analysis)...`);
 
+        const audioGcsUri = this.storageManager.getGcsUrl(audioPath);
+        const audioPublicUri = this.storageManager.getPublicUrl(audioPath);
+
         const audioFile: FileData = {
             displayName: "music track",
-            fileUri: gcsUri,
+            fileUri: audioGcsUri,
             mimeType: "audio/mp3",
         };
 
@@ -89,7 +82,6 @@ export class AudioProcessingAgent {
             JSON.stringify(jsonSchema)
         );
 
-
         const audioCountToken = await this.llm.countTokens({
             model: buildllmParams({} as any).model,
             contents: {
@@ -117,7 +109,7 @@ export class AudioProcessingAgent {
          * preventing the user's creative prompt from over-riding the technical 
          * requirements of the segmentation philosophy.
          */
-        const result = await this.llm.generateContent(buildllmParams({
+        const response = await this.llm.generateContent(buildllmParams({
             contents: [
                 {
                     role: "user",
@@ -138,6 +130,25 @@ export class AudioProcessingAgent {
             }
         }));
 
-        return result;
+        if (!response?.candidates?.[ 0 ]?.content?.parts?.[ 0 ]?.text) {
+            throw Error("No valid analysis result from LLM");
+        }
+
+        const rawText = cleanJsonOutput(response.candidates[ 0 ].content.parts[ 0 ].text);
+        const analysis: AudioAnalysis = JSON.parse(rawText);
+
+        analysis.audioGcsUri = audioGcsUri;
+        analysis.audioPublicUri = audioPublicUri;
+
+        // Initialize startFrame and endFrame for each scene
+        analysis.segments = analysis.segments.map((segment, index) => ({
+            ...segment,
+            sceneIndex: index, // Ensure 0-based sequential IDs
+            startFrame: undefined,
+            endFrame: undefined,
+        }));
+        console.log(`  Scene template generated with ${analysis.segments.length} scenes spanning ${analysis.duration} seconds.`);
+
+        return { data: { analysis }, metadata: { model: textModelName, attempts: 1, acceptedAttempt: 1 } };
     }
 }
diff --git a/src/workflow/agents/compositional-agent.ts b/src/workflow/agents/compositional-agent.ts
index b870c07..053ec25 100644
--- a/src/workflow/agents/compositional-agent.ts
+++ b/src/workflow/agents/compositional-agent.ts
@@ -1,7 +1,3 @@
-// ============================================================================
-// OPTIMIZED COMPOSITIONAL AGENT
-// ============================================================================
-
 import {
   Scene,
   Storyboard,
@@ -13,7 +9,7 @@ import {
   Location,
   Project
 } from "../../shared/types/workflow.types";
-import { cleanJsonOutput } from "../../shared/utils/utils";
+import { cleanJsonOutput, deleteBogusUrlsStoryboard } from "../../shared/utils/utils";
 import { GCPStorageManager } from "../storage-manager";
 import { composeFrameGenerationPromptMeta, composeStoryboardEnrichmentPrompt } from "../prompts/prompt-composer";
 import { buildDirectorVisionPrompt } from "../prompts/role-director";
@@ -23,6 +19,14 @@ import { buildllmParams } from "../llm/google/google-llm-params";
 import { imageModelName, qualityCheckModelName, textModelName, videoModelName } from "../llm/google/models";
 import { ThinkingLevel } from "@google/genai";
 import { AssetVersionManager } from "../asset-version-manager";
+import { SaveAssetsCallback } from "@shared/types/pipeline.types";
+import { GenerativeResultEnvelope, JobRecordExpandCreativePrompt, JobRecordGenerateStoryboard } from "@shared/types/job.types";
+
+
+
+// ============================================================================
+// COMPOSITIONAL AGENT
+// ============================================================================
 
 export class CompositionalAgent {
   private llm: TextModelController;
@@ -42,19 +46,21 @@ export class CompositionalAgent {
     this.options = options;
   }
 
-  async generateFullStoryboard(storyboard: Storyboard, enhancedPrompt: string, retryConfig: RetryConfig): Promise<Storyboard> {
+  async generateFullStoryboard(
+    storyboard: Storyboard, enhancedPrompt: string, retryConfig: RetryConfig, saveAssets: SaveAssetsCallback
+  ): Promise<GenerativeResultEnvelope<JobRecordGenerateStoryboard[ 'result' ]>> {
     console.log("   ... Enriching storyboard with a two-pass approach...");
 
-    const initialContext = await this._generateInitialStoryboardContext(storyboard.metadata.title, enhancedPrompt, storyboard.scenes, retryConfig);
+    const { data: { storyboard: initialContext } } = await this._generateInitialStoryboardContext(storyboard.metadata.title, enhancedPrompt, storyboard.scenes, retryConfig);
     console.log("Initial Context:", JSON.stringify(initialContext, null, 2));
 
     const BATCH_SIZE = 10;
     let enrichedScenes: Scene[] = [];
 
-    for (let i = 0; i < storyboard.scenes.length; i += BATCH_SIZE) {
-      const chunkScenes = storyboard.scenes.slice(i, i + BATCH_SIZE);
+    for (let i = 0; i < initialContext.scenes.length; i += BATCH_SIZE) {
+      const chunkScenes = initialContext.scenes.slice(i, i + BATCH_SIZE);
       const batchNum = Math.floor(i / BATCH_SIZE) + 1;
-      const totalBatches = Math.ceil(storyboard.scenes.length / BATCH_SIZE);
+      const totalBatches = Math.ceil(initialContext.scenes.length / BATCH_SIZE);
       console.log(`   ... Processing scene batch ${batchNum}/${totalBatches} (${chunkScenes.length} scenes)...`);
 
       const systemPrompt = composeStoryboardEnrichmentPrompt(
@@ -89,44 +95,47 @@ export class CompositionalAgent {
         if (!content) throw new Error("No content generated from LLM");
 
         const cleanedContent = cleanJsonOutput(content);
-        return JSON.parse(cleanedContent);
+        return JSON.parse(cleanedContent) as Storyboard;
       };
 
       const batchResult = await retryLlmCall(llmCall, undefined, retryConfig);
       enrichedScenes.push(...batchResult.scenes);
     }
 
-    const updatedStoryboard: Storyboard = {
+    const updatedStoryboard: Storyboard = deleteBogusUrlsStoryboard({
       ...initialContext,
       scenes: enrichedScenes.map((s, i) => ({ ...s, sceneIndex: i })),
       metadata: {
         ...initialContext.metadata,
-        totalScenes: storyboard.scenes.length,
-        duration: storyboard.scenes.length > 0 ? storyboard.scenes[ storyboard.scenes.length - 1 ].endTime : 0,
+        totalScenes: enrichedScenes.length,
+        duration: enrichedScenes.length > 0 ? enrichedScenes[ enrichedScenes.length - 1 ].endTime : 0,
         enhancedPrompt: enhancedPrompt,
       } as Storyboard[ 'metadata' ]
-    };
+    });
     this.validateTimingPreservation(storyboard.scenes, updatedStoryboard.scenes);
 
-    await this.assetManager.createVersionedAssets(
-      { projectId: updatedStoryboard.scenes[ 0 ].projectId },
+    saveAssets(
+      { projectId: updatedStoryboard.metadata.projectId },
       'storyboard',
       'text',
       [ JSON.stringify(updatedStoryboard) ],
       { model: textModelName }
     );
+
     console.log(` Storyboard enriched successfully:`);
     console.log(`  - Title: ${updatedStoryboard.metadata.title || "Untitled"}`);
     console.log(`  - Duration: ${updatedStoryboard.metadata.duration}`);
     console.log(`  - Total Scenes: ${updatedStoryboard.metadata.totalScenes}`);
     console.log(`  - Characters: ${updatedStoryboard.characters.length}`);
     console.log(`  - Locations: ${updatedStoryboard.locations.length}`);
-    console.log(`  - Creative prompt added to metadata: ${((updatedStoryboard.metadata as any).enhancedPrompt as string).slice(0, 50)}...`);
+    console.log(`  - Creative prompt added to metadata: ${updatedStoryboard.metadata.enhancedPrompt.slice(0, 50)}...`);
 
-    return updatedStoryboard;
+    return { data: { storyboard: updatedStoryboard }, metadata: { model: textModelName, attempts: 1, acceptedAttempt: 1 } };
   }
 
-  private async _generateInitialStoryboardContext(title: string, enhancedPrompt: string, scenes: Scene[], retryConfig: RetryConfig): Promise<Storyboard> {
+  private async _generateInitialStoryboardContext(
+    title: string, enhancedPrompt: string, scenes: Scene[], retryConfig: RetryConfig
+  ): Promise<GenerativeResultEnvelope<JobRecordGenerateStoryboard[ 'result' ]>> {
     console.log("   ... Generating initial context (metadata, characters, locations)...");
 
     const totalDuration = scenes.length > 0 ? scenes[ scenes.length - 1 ].endTime : 0;
@@ -167,7 +176,7 @@ export class CompositionalAgent {
       if (!content) throw new Error("No content generated from LLM for initial context");
 
       const cleanedContent = cleanJsonOutput(content);
-      const parsedContext = JSON.parse(cleanedContent);
+      const parsedContext = JSON.parse(cleanedContent) as Storyboard;
 
       if (!parsedContext.metadata) {
         throw new Error("Failed to generate metadata in initial context");
@@ -175,11 +184,12 @@ export class CompositionalAgent {
 
       return {
         ...parsedContext,
-        scenes: [] // Scenes will be populated in the second pass
-      };
+        scenes: [] // Scenes will be populated in the next pass
+      } as Storyboard;
     };
 
-    return retryLlmCall(llmCall, undefined, retryConfig);
+    const storyboard = await retryLlmCall(llmCall, undefined, retryConfig);
+    return { data: { storyboard }, metadata: { model: textModelName, attempts: 1, acceptedAttempt: 1 } };
   }
 
   private validateTimingPreservation(originalScenes: Scene[], enrichedScenes: Scene[]): void {
@@ -205,7 +215,7 @@ export class CompositionalAgent {
     title: string,
     userPrompt: string,
     retryConfig: RetryConfig,
-  ): Promise<string> {
+  ): Promise<GenerativeResultEnvelope<JobRecordExpandCreativePrompt[ 'result' ]>> {
 
     const systemPrompt = buildDirectorVisionPrompt(title, userPrompt);
 
@@ -231,19 +241,22 @@ export class CompositionalAgent {
         throw new Error("No content generated from LLM for prompt expansion");
       }
 
-      console.log(` Creative prompt expanded: ${userPrompt.substring(0, 50)}...  ${expandedPrompt.length} chars`);
+      console.log(` Prompt expanded: ${userPrompt.substring(0, 10)}...  ${expandedPrompt.length} chars`);
 
-      return expandedPrompt;
+      return expandedPrompt as string;
     };
 
-    return await retryLlmCall(llmCall, undefined, retryConfig);
+    const expandedPrompt = await retryLlmCall(llmCall, undefined, retryConfig);
+    return { data: { expandedPrompt }, metadata: { model: textModelName, attempts: 1, acceptedAttempt: 1 } };
   }
 
   /**
    * Generates a storyboard from creative prompt without audio timing constraints.
    * Used when no audio file is provided.
    */
-  async generateStoryboardFromPrompt(title: string, enhancedPrompt: string, retryConfig: RetryConfig): Promise<Pick<Project, "metadata" | "characters" | "scenes" | "locations">> {
+  async generateStoryboardFromPrompt(
+    title: string, enhancedPrompt: string, retryConfig: RetryConfig, saveAssets: SaveAssetsCallback
+  ): Promise<GenerativeResultEnvelope<JobRecordGenerateStoryboard[ 'result' ]>> {
     console.log("   ... Generating full storyboard from creative prompt (no audio)...");
 
     const jsonSchema = getJsonSchema(StoryboardSchema);
@@ -278,18 +291,19 @@ export class CompositionalAgent {
         }
       }
 
-      return storyboard;
+      return deleteBogusUrlsStoryboard(storyboard);
     };
 
     const storyboard = await retryLlmCall(llmCall, undefined, { initialDelay: 1000, ...retryConfig, maxRetries: 3 });
 
-    await this.assetManager.createVersionedAssets(
+    saveAssets(
       { projectId: storyboard.scenes[ 0 ].projectId },
       'storyboard',
       'text',
       [ JSON.stringify(storyboard) ],
       { model: textModelName }
     );
+
     console.log(` Storyboard generated successfully:`);
     console.log(`  - Title: ${storyboard.metadata.title || "Untitled"}`);
     console.log(`  - Duration: ${storyboard.metadata.duration}s`);
@@ -298,6 +312,6 @@ export class CompositionalAgent {
     console.log(`  - Locations: ${storyboard.locations.length}`);
     console.log(`  - Creative prompt added to metadata: ${((storyboard.metadata as any).enhancedPrompt as string).slice(0, 50)}...`);
 
-    return storyboard;
+    return { data: { storyboard }, metadata: { model: textModelName, attempts: 1, acceptedAttempt: 1 } };
   }
 }
diff --git a/src/workflow/agents/continuity-manager.ts b/src/workflow/agents/continuity-manager.ts
index f5446ec..8ac448e 100644
--- a/src/workflow/agents/continuity-manager.ts
+++ b/src/workflow/agents/continuity-manager.ts
@@ -24,7 +24,8 @@ import { evolveCharacterState, evolveLocationState } from "./state-evolution";
 import { GraphInterrupt } from "@langchain/langgraph";
 import { cleanJsonOutput, getAllBestFromAssets } from "../../shared/utils/utils";
 import { AssetVersionManager } from "../asset-version-manager";
-import { OnGenerateCallback, OnProgressCallback } from "@shared/types/pipeline.types";
+import { SaveAssetsCallback, UpdateSceneCallback, OnAttemptCallback } from "@shared/types/pipeline.types";
+import { GenerativeResultEnvelope, JobRecordGenerateCharacterAssets, JobRecordGenerateLocationAssets, JobRecordGenerateSceneFrames } from "@shared/types/job.types";
 
 
 
@@ -60,7 +61,7 @@ export class ContinuityManagerAgent {
         scene: Scene,
         state: Project,
         overridePrompt: boolean,
-        onGenerate: OnGenerateCallback,
+        saveAssets: SaveAssetsCallback,
     ): Promise<{
         enhancedPrompt: string;
         startFrame?: string;
@@ -96,7 +97,6 @@ export class ContinuityManagerAgent {
         const locationReferenceImages = locationAssets['location_image']?.data ? [ locationAssets['location_image'].data ] : [];
 
         let enhancedPrompt = "";
-        let overrideUsed = false;
         if (overridePrompt) {
             const [ promptAsset ] = await this.assetManager.getBestVersion(
                 { projectId: scene.projectId, sceneId: scene.id },
@@ -104,14 +104,13 @@ export class ContinuityManagerAgent {
             );
             if (promptAsset) {
                 enhancedPrompt = promptAsset.data;
-                overrideUsed = true;
                 console.log(`    Using prompt override for Scene ${scene.id}`);
             } else {
                 console.log(` Prompt asset not found. Override will not be used .`);
             }
         }
 
-        if (!overrideUsed) {
+        if (!enhancedPrompt) {
             console.log(`    Generating enhanced video prompt for Scene ${scene.id} via LLM...`);
             let metaPrompt = composeEnhancedSceneGenerationPromptMetav1(
                 scene,
@@ -139,7 +138,7 @@ export class ContinuityManagerAgent {
                 enhancedPrompt = cleanJsonOutput(response.text);
             }
             enhancedPrompt += composeGenerationRules(generationRules);
-            onGenerate(
+            saveAssets(
                 { projectId: scene.projectId, sceneId: scene.id },
                 'scene_prompt',
                 'text',
@@ -164,10 +163,9 @@ export class ContinuityManagerAgent {
     async generateCharacterAssets(
         characters: Character[],
         generationRules: string[],
-        onGenerate: OnGenerateCallback,
-        onProgress?: OnProgressCallback<Scene>,
-        onRetry?: (attempt: number) => Promise<number>,
-    ): Promise<Character[]> {
+        saveAssets: SaveAssetsCallback,
+        onAttempt: OnAttemptCallback,
+    ): Promise<GenerativeResultEnvelope<JobRecordGenerateCharacterAssets[ 'result' ]>> {
 
         const charactersToGenerateIds: string[] = [];
         const charactersToGenerate: Character[] = [];
@@ -189,7 +187,7 @@ export class ContinuityManagerAgent {
                 const attempt = attempts[ index ];
 
                 const imagePrompt = buildCharacterImagePrompt(character, generationRules);
-                onGenerate(
+                saveAssets(
                     { projectId: character.projectId, characterIds: [ character.id ] },
                     'character_prompt',
                     'text',
@@ -205,7 +203,7 @@ export class ContinuityManagerAgent {
                     console.log(`   Found existing image for: ${character.name}`);
                     const imageUrl = this.storageManager.getGcsUrl(imagePath);
 
-                    onGenerate(
+                    saveAssets(
                         { projectId: character.projectId, characterIds: [ character.id ] },
                         'character_image',
                         'image',
@@ -223,7 +221,7 @@ export class ContinuityManagerAgent {
                         const outputMimeType = "image/png";
                         const result = await retryLlmCall(
                             (params) => this.imageModel.generateContent({
-                                model: params.model,
+                                model: params.imageModel,
                                 contents: [ params.prompt ],
                                 config: {
                                     abortSignal: this.options?.signal,
@@ -237,7 +235,7 @@ export class ContinuityManagerAgent {
                             }),
                             {
                                 prompt: imagePrompt,
-                                model: imageModelName,
+                                imageModel: imageModelName,
                             },
                             {
                                 attempt,
@@ -246,7 +244,7 @@ export class ContinuityManagerAgent {
                                 projectId: character.projectId
                             },
                             async (error, attempt, params) => {
-                                attempt = await onRetry?.(attempt) || attempt;
+                                onAttempt(attempt);
                                 return {
                                     attempt,
                                     params
@@ -270,7 +268,7 @@ export class ContinuityManagerAgent {
                             outputMimeType,
                         );
 
-                        onGenerate(
+                        saveAssets(
                             { projectId: character.projectId, characterIds: [ character.id ] },
                             'character_image',
                             'image',
@@ -292,7 +290,7 @@ export class ContinuityManagerAgent {
         }
 
         // Ensure all characters have their state initialized with enhanced temporal tracking.
-        return updatedCharacters.map(character => ({
+        const finalizedCharacters = updatedCharacters.map(character => ({
             ...character,
             state: {
                 lastSeen: character.state?.lastSeen || undefined,
@@ -319,16 +317,17 @@ export class ContinuityManagerAgent {
 
             }
         }));
+        return { data: { characters: finalizedCharacters }, metadata: { model: imageModelName, attempts: 1, acceptedAttempt: 1 } };
     }
 
 
     async generateSceneFramesBatch(
         project: Project,
         assetKey: 'scene_start_frame' | 'scene_end_frame',
-        onGenerate: OnGenerateCallback,
-        onProgress?: OnProgressCallback<Scene>,
-        onRetry?: (attempt: number) => Promise<number>,
-    ): Promise<Scene[]> {
+        saveAssets: SaveAssetsCallback,
+        updateScene: UpdateSceneCallback,
+        onAttempt: OnAttemptCallback,
+    ): Promise<GenerativeResultEnvelope<JobRecordGenerateSceneFrames[ 'result' ]>> {
         console.log(`\n Generating ${assetKey} for ${project.scenes.length} scenes in batch...`);
         const updatedScenes: Scene[] = [];
 
@@ -369,7 +368,7 @@ export class ContinuityManagerAgent {
                     console.log(`   Found existing ${assetKey} for Scene ${scene.id} in storage`);
                     const url = this.storageManager.getGcsUrl(framePath);
 
-                    onGenerate(
+                    saveAssets(
                         { projectId: project.id, sceneId: scene.id },
                         assetKey,
                         'image',
@@ -396,7 +395,7 @@ export class ContinuityManagerAgent {
                          return a['location_image']?.data ? [a['location_image'].data] : [];
                     });
 
-                    const frame = await this.frameComposer.generateImage(
+                    const result = await this.frameComposer.generateImage(
                         currentScene,
                         framePrompt,
                         assetKey === "scene_start_frame" ? "start" : "end",
@@ -404,20 +403,21 @@ export class ContinuityManagerAgent {
                         sceneLocations,
                         prevEndFrameOrSceneStartFrame,
                         [ ...charImages, ...locImages ],
-                        undefined,
-                        onProgress
+                        saveAssets,
+                        updateScene,
+                        onAttempt,
                     );
                     
-                    onGenerate(
+                    saveAssets(
                         { projectId: project.id, sceneId: scene.id },
                         assetKey,
                         'image',
-                        [ frame ],
+                        [ result.data.image ],
                         { model: imageModelName, prompt: framePrompt },
                         true
                     );
 
-                    onGenerate(
+                    saveAssets(
                         { projectId: project.id, sceneId: scene.id },
                         promptKey,
                         'text',
@@ -434,24 +434,24 @@ export class ContinuityManagerAgent {
                 `Saved ${assetKey}`;
             currentScene.status =
                 "complete";
-            if (onProgress) onProgress(currentScene);
 
             updatedScenes.push(currentScene);
+
+            updateScene(currentScene);
         }
-        return updatedScenes;
+        return { data: { updatedScenes }, metadata: { model: imageModelName, attempts: 1, acceptedAttempt: 1 } };
     }
 
     async generateLocationAssets(
         locations: Location[],
         generationRules: string[],
-        onGenerate: OnGenerateCallback,
-        onProgress?: OnProgressCallback<Scene>,
-        onRetry?: (attempt: number) => Promise<number>,
-    ): Promise<Location[]> {
+        saveAssets: SaveAssetsCallback,
+        onAttempt: OnAttemptCallback,
+    ): Promise<GenerativeResultEnvelope<JobRecordGenerateLocationAssets[ 'result' ]>> {
 
         const locationsToGenerateIds: string[] = [];
         const locationsToGenerate: Location[] = [];
-        const updatedLocations: Location[] = [ ...locations ];
+        let updatedLocations: Location[] = [ ...locations ];
         for (const loc of locations) {
             const assets = getAllBestFromAssets(loc.assets);
             if (!assets[ 'location_image' ]?.data) {
@@ -475,7 +475,7 @@ export class ContinuityManagerAgent {
                 if (exists) {
                     console.log(`   Found existing image for: ${location.name}`);
                     const imageUrl = this.storageManager.getGcsUrl(imagePath);
-                    onGenerate(
+                    saveAssets(
                         { projectId: location.projectId, locationIds: [ location.id ] },
                         'location_image',
                         'image',
@@ -518,7 +518,7 @@ export class ContinuityManagerAgent {
                                 projectId: location.projectId
                             },
                             async (error, attempt, params) => {
-                                attempt = onRetry ? await onRetry(attempt) : attempt;
+                                onAttempt(attempt);
                                 return {
                                     attempt,
                                     params,
@@ -542,7 +542,7 @@ export class ContinuityManagerAgent {
                             outputMimeType,
                         );
 
-                        onGenerate(
+                        saveAssets(
                             { projectId: location.projectId, locationIds: [ location.id ] },
                             'location_image',
                             'image',
@@ -551,7 +551,7 @@ export class ContinuityManagerAgent {
                             true
                         );
 
-                        onGenerate(
+                        saveAssets(
                             { projectId: location.projectId, locationIds: [ location.id ] },
                             'location_prompt',
                             'text',
@@ -572,7 +572,7 @@ export class ContinuityManagerAgent {
         }
 
         // Ensure all locations have their state initialized with enhanced temporal tracking.
-        return updatedLocations.map(location => ({
+        updatedLocations = updatedLocations.map(location => ({
             ...location,
             state: {
                 lastUsed: location.state?.lastUsed || undefined,
@@ -595,14 +595,19 @@ export class ContinuityManagerAgent {
                 temperatureIndicators: location.state?.temperatureIndicators || [],
             }
         }));
+
+        return { data: { locations: updatedLocations }, metadata: { model: imageModelName, attempts: 1, acceptedAttempt: 1 } };
     }
 
+    /**
+     * Use state evolution logic to track progressive narrative changes
+     * across scenes
+     */
     updateNarrativeState(
         scene: Scene,
         currentStoryboardState: Project
     ): Project {
 
-        // Use enhanced state evolution logic to track progressive changes
         const updatedCharacters = currentStoryboardState.characters.map((char: Character) => {
             if (scene.characters.includes(char.id)) {
                 // Evolve character state based on scene narrative
diff --git a/src/workflow/agents/frame-composition-agent.ts b/src/workflow/agents/frame-composition-agent.ts
index 4a70df6..77bc650 100644
--- a/src/workflow/agents/frame-composition-agent.ts
+++ b/src/workflow/agents/frame-composition-agent.ts
@@ -2,9 +2,9 @@ import { FileData, Modality, Part, ThinkingLevel } from "@google/genai";
 import { GCPStorageManager, GcsObjectPathParams } from "../storage-manager";
 import { TextModelController } from "../llm/text-model-controller";
 import { buildllmParams } from "../llm/google/google-llm-params";
-import { imageModelName } from "../llm/google/models";
+import { imageModelName, qualityCheckModelName } from "../llm/google/models";
 import { QualityCheckAgent } from "./quality-check-agent";
-import { AssetStatus, Character, FrameGenerationResult, Location, QualityEvaluationResult, Scene } from "../../shared/types/workflow.types";
+import { Character, Location, QualityEvaluationResult, Scene } from "../../shared/types/workflow.types";
 import { retryLlmCall } from "../../shared/utils/llm-retry";
 import { RAIError } from "../../shared/utils/errors";
 import { GraphInterrupt } from "@langchain/langgraph";
@@ -12,7 +12,8 @@ import { composeFrameGenerationPromptMeta, composeGenerationRules } from "../pro
 import { cleanJsonOutput } from "../../shared/utils/utils";
 import { AssetVersionManager } from "../asset-version-manager";
 import { QualityRetryHandler } from "@shared/utils/quality-retry-handler";
-import { OnGenerateCallback } from "@shared/types/pipeline.types";
+import { OnAttemptCallback, SaveAssetsCallback, UpdateSceneCallback } from "@shared/types/pipeline.types";
+import { GenerativeResultEnvelope, JobRecordFrameRender } from "@shared/types/job.types";
 
 type FrameImageObjectParams = Extract<GcsObjectPathParams, ({ type: "scene_start_frame"; } | { type: "scene_end_frame"; })>;
 
@@ -41,7 +42,6 @@ export class FrameCompositionAgent {
     }
 
     async prepareImageInputs(urls: string[]): Promise<FileData[]> {
-
         return Promise.all(
             urls.map(async (u) => {
                 const mimeType = await this.storageManager.getObjectMimeType(u);
@@ -67,51 +67,58 @@ export class FrameCompositionAgent {
         sceneLocations: Location[],
         previousFrame: string | undefined,
         referenceImages: string[],
-        onGenerate?: OnGenerateCallback,
-        onProgress?: (scene: Scene, progress?: number) => void,
-
-    ): Promise<string> {
+        saveAssets: SaveAssetsCallback,
+        updateScene: UpdateSceneCallback,
+        onAttempt: OnAttemptCallback,
+    ): Promise<GenerativeResultEnvelope<JobRecordFrameRender['result']>> {
         if (!this.qualityAgent.qualityConfig.enabled && !!this.qualityAgent.evaluateFrameQuality) {
             const [ attempt ] = await this.assetManager.getNextVersionNumber(
                 { projectId: scene.projectId, sceneId: scene.id },
                 framePosition === "start" ? "scene_start_frame" : "scene_end_frame",
             );
-            const frame = await this.executeGenerateImage(
+            const image = await this.executeGenerateImage(
                 scene,
                 prompt,
                 framePosition,
                 { type: framePosition === "start" ? "scene_start_frame" : "scene_end_frame", sceneId: scene.id, attempt },
                 previousFrame,
                 referenceImages,
-                onProgress
+                updateScene
             );
 
-            onGenerate?.(
+            saveAssets(
                 { projectId: scene.projectId },
                 framePosition === "start" ? "scene_start_frame" : "scene_end_frame",
                 'image',
-                [ frame ],
+                [ image ],
                 {
                     model: imageModelName,
                     evaluation: null
                 }
             );
 
-            return frame;
+            return {
+                data: { scene, image },
+                metadata: {
+                    attempts: 1,
+                    acceptedAttempt: 1,
+                    model: imageModelName
+                }
+            };
         }
 
-        const result = await this.generateImageWithQualityRetry(scene, prompt, framePosition, sceneCharacters, sceneLocations, previousFrame, referenceImages, onGenerate, onProgress);
+        const {data, metadata } = await this.generateImageWithQualityRetry(scene, prompt, framePosition, sceneCharacters, sceneLocations, previousFrame, referenceImages, saveAssets, updateScene, onAttempt);
 
-        if (result.evaluation) {
-            console.log(`    Final: ${(result.finalScore * 100).toFixed(1)}% after ${result.attempts} attempt(s)`);
+        if (metadata.evaluation) {
+            console.log(`    Final: ${(metadata.evaluation.score * 100).toFixed(1)}% after ${ metadata.attempts} attempt(s)`);
         }
 
-        if (result.evaluation?.ruleSuggestion) {
+        if (metadata.evaluation?.ruleSuggestion) {
             console.log(`\n GENERATION RULE ADDED`);
-            console.log(`   "${result.evaluation.ruleSuggestion}"`);
+            console.log(`   "${metadata.evaluation.ruleSuggestion}"`);
         }
 
-        return result.frame;
+        return { data: { ...data, scene }, metadata };
     }
 
     private async generateImageWithQualityRetry(
@@ -122,20 +129,21 @@ export class FrameCompositionAgent {
         locations: Location[],
         previousFrame: string | undefined,
         referenceImages: string[] = [],
-        onGenerate?: OnGenerateCallback,
-        onProgress?: (scene: Scene, progress?: number) => void
-        // onStep?: (scene: Scene, progress?: number) => void
-    ): Promise<FrameGenerationResult> {
+        saveAssets: SaveAssetsCallback,
+        updateScene: UpdateSceneCallback,
+        onAttempt: OnAttemptCallback,
+    ): Promise<GenerativeResultEnvelope<{ image: string; }>> {
 
-        let frame: string | null = null;
+        let image: string | null = null;
         let objectParams: FrameImageObjectParams;
 
         const acceptanceThreshold = this.qualityAgent.qualityConfig.minorIssueThreshold;
-        let bestFrame: string | null = null;
+        let bestImage: string | null = null;
         let bestEvaluation: QualityEvaluationResult | null = null;
         let bestScore = 0;
         let numAttempts = 1;
         let totalAttempts = 0;
+        let bestAttemptNumber = 0;
         const [ currentAttemptNumber ] = await this.assetManager.getNextVersionNumber(
             { projectId: scene.projectId, sceneId: scene.id },
             framePosition === "start" ? "scene_start_frame" : "scene_end_frame"
@@ -150,7 +158,7 @@ export class FrameCompositionAgent {
             let score = 0;
 
             try {
-                frame = await this.generateImageWithSafetyRetry(
+                image = await this.generateImageWithSafetyRetry(
                     scene,
                     prompt,
                     framePosition,
@@ -158,46 +166,60 @@ export class FrameCompositionAgent {
                     currentAttemptNumber,
                     previousFrame,
                     referenceImages,
-                    onProgress
+                    updateScene
                 );
 
                 console.log(`   Quality checking ${framePosition} frame for Scene ${scene.id}...`);
+
                 scene.progressMessage = `Quality checking ${framePosition} frame...`;
                 scene.status = "evaluating";
-                if (onProgress) onProgress(scene);
+                updateScene(scene, false);
+
                 evaluation = await this.qualityAgent.evaluateFrameQuality(
-                    frame,
+                    image,
                     scene,
                     framePosition,
                     characters,
                     locations,
                 );
-                onGenerate?.(
-                    { projectId: scene.projectId },
+                saveAssets(
+                    { projectId: scene.projectId, sceneId: scene.id },
                     framePosition === "start" ? "scene_start_frame" : "scene_end_frame",
                     'image',
-                    [ frame ],
+                    [ image ],
                     {
                         model: imageModelName,
                         evaluation
                     }
                 );
+                saveAssets(
+                    { projectId: scene.projectId, sceneId: scene.id },
+                    "frame_quality_evaluation",
+                    'text',
+                    [ JSON.stringify(evaluation) ],
+                    {
+                        model: qualityCheckModelName,
+                    }
+                );
 
-                score = this.qualityAgent[ "calculateOverallScore" ](evaluation.scores);
-                if (score > bestScore) {
+                if (evaluation.score > bestScore) {
                     bestScore = score;
-                    bestFrame = frame;
+                    bestImage = image;
+                    bestAttemptNumber = currentAttemptNumber;
                     bestEvaluation = evaluation;
                 }
-                this.qualityAgent[ "logAttemptResult" ](numAttempts, score, evaluation.overall);
+                this.qualityAgent[ "logAttemptResult" ](numAttempts, score, evaluation.grade);
 
                 if (score >= acceptanceThreshold) {
                     console.log(`    Quality acceptable (${(score * 100).toFixed(1)}%)`);
                     return {
-                        frame,
-                        attempts: totalAttempts,
-                        finalScore: score,
-                        evaluation
+                        data: { image: bestImage! },
+                        metadata: {
+                            model: imageModelName,
+                            attempts: totalAttempts,
+                            acceptedAttempt: bestAttemptNumber,
+                            evaluation
+                        }
                     };
                 }
 
@@ -218,11 +240,11 @@ export class FrameCompositionAgent {
                 if (error instanceof GraphInterrupt) throw Error;
 
                 console.warn(`    Frame quality issues for ${this.storageManager.getObjectPath(objectParams)}`);
-                if (evaluation && frame) {
+                if (evaluation && image) {
                     const score = this.qualityAgent[ "calculateOverallScore" ](evaluation.scores);
                     if (score > bestScore) {
                         bestScore = score;
-                        bestFrame = frame;
+                        bestImage = image;
                         bestEvaluation = evaluation;
                     }
                 }
@@ -230,6 +252,8 @@ export class FrameCompositionAgent {
                 if (numAttempts < this.qualityAgent.qualityConfig.maxRetries) {
                     console.log(`   Retrying frame generation...`);
 
+                    onAttempt(numAttempts);
+
                     const GENERATE_IMAGE_SUCCESS_COOLDOWN = 6000;
                     console.log(`Waiting ${GENERATE_IMAGE_SUCCESS_COOLDOWN / 1000}s to avoid rate limit`);
                     await new Promise(resolve => setTimeout(resolve, GENERATE_IMAGE_SUCCESS_COOLDOWN));
@@ -237,16 +261,19 @@ export class FrameCompositionAgent {
             }
         }
 
-        if (bestFrame && bestScore > 0) {
+        if (bestImage && bestScore > 0) {
             const scorePercent = (bestScore * 100).toFixed(1);
             const thresholdPercent = (acceptanceThreshold * 100).toFixed(0);
             console.warn(`    Using best attempt: ${scorePercent}% (threshold: ${thresholdPercent}%)`);
             return {
-                frame: bestFrame,
-                attempts: totalAttempts,
-                finalScore: bestScore,
-                evaluation: bestEvaluation!,
-                warning: `Quality below threshold after ${totalAttempts} attempts`
+                data: { image: bestImage },
+                metadata: {
+                    model: imageModelName,
+                    attempts: totalAttempts,
+                    acceptedAttempt: bestAttemptNumber,
+                    evaluation: bestEvaluation!,
+                    warning: `Quality below threshold after ${totalAttempts} attempts`
+                }
             };
         }
 
@@ -303,8 +330,6 @@ export class FrameCompositionAgent {
         // )
 
         throw new Error(`Failed to generate acceptable frame image after ${totalAttempts} attempts`);
-
-
     }
 
     /**
@@ -318,7 +343,7 @@ export class FrameCompositionAgent {
         attempt: number,
         previousFrame: string | undefined,
         referenceImages: string[] = [],
-        onProgress?: (scene: Scene, progress?: number) => void
+        updateScene: UpdateSceneCallback,
     ) {
 
         const attemptLabel = attempt ? ` (Quality Attempt ${attempt})` : "";
@@ -331,7 +356,7 @@ export class FrameCompositionAgent {
                 objectParams,
                 previousFrame,
                 referenceImages,
-                onProgress
+                updateScene,
             ),
             { prompt },
             {
@@ -361,14 +386,13 @@ export class FrameCompositionAgent {
         pathParams: FrameImageObjectParams,
         previousFrame: string | undefined,
         referenceImages: string[],
-        onProgress?: (scene: Scene, progress?: number) => void
+        updateScene: UpdateSceneCallback,
     ) {
         console.log(`   [FrameCompositionAgent] Generating frame for scene ${pathParams.sceneId} (${pathParams.type})...`);
 
-
         scene.progressMessage = `Generating ${pathParams.type.includes('start') ? 'start' : 'end'} frame image...`;
         scene.status = "generating";
-        if (onProgress) onProgress(scene);
+        updateScene(scene, false);
 
         let contents: Part[] = [ { text: `Frame Description: ${prompt}` } ];
         const validReferenceImageUrls = [ previousFrame, ...referenceImages ].map(obj => obj).filter((url): url is string => typeof url === 'string' && url.length > 0);
@@ -416,7 +440,7 @@ export class FrameCompositionAgent {
 
         scene.progressMessage = `Generated ${pathParams.type.includes('start') ? 'start' : 'end'} frame image`;
         scene.status = "complete";
-        if (onProgress) onProgress(scene, 100);
+        updateScene(scene, false);
 
         return frame;
     }
diff --git a/src/workflow/agents/quality-check-agent.ts b/src/workflow/agents/quality-check-agent.ts
index 3598244..644c872 100644
--- a/src/workflow/agents/quality-check-agent.ts
+++ b/src/workflow/agents/quality-check-agent.ts
@@ -10,7 +10,7 @@ import { FileData } from "@google/genai";
 import { buildSafetyGuidelinesPrompt } from "../prompts/safety-instructions";
 import { detectRelevantDomainRules, getProactiveRules } from "../prompts/generation-rules-presets";
 import { qualityCheckModelName } from "../llm/google/models";
-import { OnProgressCallback } from "@shared/types/pipeline.types";
+import { UpdateSceneCallback } from "@shared/types/pipeline.types";
 
 
 
@@ -172,7 +172,8 @@ export class QualityCheckAgent {
 
     const evaluation: QualityEvaluationResult = {
       ...evaluationData,
-      overall: overallRating,
+      grade: overallRating,
+      score: overallScore,
     };
 
     this.logEvaluationResults(scene.id, evaluation, overallScore);
@@ -190,12 +191,12 @@ export class QualityCheckAgent {
     location: Location,
     attempt: number,
     previousScene?: Scene,
-    onProgress?: OnProgressCallback<Scene>,
+    updateScene?: UpdateSceneCallback,
     activeRules?: string[]
   ): Promise<QualityEvaluationResult> {
     scene.progressMessage = "Evaluating scene quality...";
     scene.status = "evaluating";
-    if (onProgress) onProgress(scene);
+    updateScene?.(scene);
 
     const relevantRules = activeRules && activeRules.length > 0
       ? activeRules
@@ -250,7 +251,8 @@ export class QualityCheckAgent {
 
     const evaluation: QualityEvaluationResult = {
       ...evaluationData,
-      overall: overallRating,
+      grade: overallRating,
+      score: overallScore,
     };
 
     this.logEvaluationResults(scene.id, evaluation, overallScore);
@@ -266,7 +268,7 @@ export class QualityCheckAgent {
     scene: Scene,
     characters: Character[],
     attempt: number,
-    onProgress?: OnProgressCallback<Scene>,
+    updateScene?: UpdateSceneCallback,
   ): Promise<string> {
 
     if (!evaluation.promptCorrections || evaluation.promptCorrections.length === 0) {
@@ -277,7 +279,7 @@ export class QualityCheckAgent {
     console.log(`    Attempt ${attempt + 1}: Applying ${evaluation.promptCorrections.length} corrections`);
     scene.progressMessage = `Applying ${evaluation.promptCorrections.length} corrections...`;
     scene.status = "evaluating";
-    if (onProgress) onProgress(scene);
+    updateScene?.(scene);
 
     const correctionPrompt = buildCorrectionPrompt(originalPrompt, scene, evaluation.promptCorrections);
 
@@ -367,7 +369,7 @@ export class QualityCheckAgent {
   /**
    * Determine overall rating from score
    */
-  private determineOverallRating(score: number): QualityEvaluationResult[ "overall" ] {
+  private determineOverallRating(score: number): QualityEvaluationResult[ "grade" ] {
     if (score >= this.qualityConfig.acceptThreshold) return "ACCEPT";
     if (score >= this.qualityConfig.minorIssueThreshold) return "ACCEPT_WITH_NOTES";
     if (score >= this.qualityConfig.majorIssueThreshold) return "REGENERATE_MINOR";
@@ -393,7 +395,7 @@ export class QualityCheckAgent {
   ): void {
     const scorePercentage = (overallScore * 100).toFixed(1);
 
-    console.log(`   Overall Rating ${id}: ${evaluation.overall} (${scorePercentage}%)`);
+    console.log(`   Overall Rating ${id}: ${evaluation.grade} (${scorePercentage}%)`);
 
     Object.entries(evaluation.scores).forEach(([ category, score ]) => {
       const icon = score.rating === "PASS" ? "" :
diff --git a/src/workflow/agents/scene-generator.ts b/src/workflow/agents/scene-generator.ts
index e02ef7c..a3b2e1e 100644
--- a/src/workflow/agents/scene-generator.ts
+++ b/src/workflow/agents/scene-generator.ts
@@ -1,7 +1,7 @@
 import { PersonGeneration, Video, Image, VideoGenerationReferenceType, Operation, GenerateVideosResponse } from "@google/genai";
 import { GCPStorageManager } from "../storage-manager";
-import { Character, Location, GeneratedScene, QualityEvaluationResult, Scene, SceneGenerationResult } from "../../shared/types/workflow.types";
-import { OnCompleteCallback, OnProgressCallback } from "@shared/types/pipeline.types";
+import { Character, Location, QualityEvaluationResult, Scene, SceneGenerationResult } from "../../shared/types/workflow.types";
+import { GetAttemptMetricCallback, OnAttemptCallback, SaveAssetsCallback, UpdateSceneCallback } from "@shared/types/pipeline.types";
 import { RAIError } from "../../shared/utils/errors";
 import ffmpeg from "fluent-ffmpeg";
 import { buildVideoGenerationParams } from "../llm/google/google-llm-params";
@@ -12,7 +12,8 @@ import { VideoModelController } from "../llm/video-model-controller";
 import { QualityCheckAgent } from "./quality-check-agent";
 import { GraphInterrupt } from "@langchain/langgraph";
 import { AssetVersionManager } from "../asset-version-manager";
-import { videoModelName } from "../llm/google/models";
+import { qualityCheckModelName, videoModelName } from "../llm/google/models";
+import { GenerativeResultEnvelope, JobRecordGenerateSceneVideo } from "@shared/types/job.types";
 
 
 
@@ -21,7 +22,6 @@ export class SceneGeneratorAgent {
     private storageManager: GCPStorageManager;
     private qualityAgent: QualityCheckAgent;
     private options?: { signal?: AbortSignal; };
-    private assetManager: AssetVersionManager;
 
     constructor(
         videoModel: VideoModelController,
@@ -33,7 +33,6 @@ export class SceneGeneratorAgent {
         this.videoModel = videoModel;
         this.qualityAgent = qualityAgent;
         this.storageManager = storageManager;
-        this.assetManager = assetManager;
 
         this.options = options;
     }
@@ -54,9 +53,10 @@ export class SceneGeneratorAgent {
         characterReferenceImages,
         locationReferenceImages,
         generateAudio = false,
-        onComplete,
-        onProgress,
-        onRetry,
+        saveAssets,
+        updateScene,
+        onAttempt,
+        saveMetric,
         generationRules,
     }: {
         scene: Scene,
@@ -69,12 +69,13 @@ export class SceneGeneratorAgent {
         endFrame?: string,
         characterReferenceImages?: string[],
         locationReferenceImages?: string[],
-        generateAudio: boolean,
-            onComplete?: OnCompleteCallback<Scene>,
-            onProgress?: OnProgressCallback<Scene>,
-        onRetry?: (attempt: number) => Promise<number>,
+            generateAudio: boolean,
+            saveAssets: SaveAssetsCallback,
+            updateScene: UpdateSceneCallback,
+            onAttempt: OnAttemptCallback,
+            saveMetric: GetAttemptMetricCallback,
         generationRules?: string[],
-    }): Promise<SceneGenerationResult> {
+        }): Promise<GenerativeResultEnvelope<JobRecordGenerateSceneVideo[ 'result' ]>> {
 
         console.log(`\n[Scene Generator]: Generating Scene ${scene.id}: ${formatTime(scene.duration)}`);
 
@@ -90,12 +91,13 @@ export class SceneGeneratorAgent {
                 previousScene,
                 generateAudio,
                 generationRules,
-                onProgress,
-                onRetry,
+                updateScene,
+                onAttempt,
+                saveMetric,
             );
 
             const setBestVersion = true;
-            this.assetManager.createVersionedAssets(
+            saveAssets(
                 { projectId: scene.projectId, sceneId: scene.id },
                 'scene_video',
                 'video',
@@ -104,20 +106,15 @@ export class SceneGeneratorAgent {
                 setBestVersion,
             );
 
-            if (onComplete) {
-                onComplete(generated.scene, {
-                    attemptNumber: version,
-                    finalScore: 1.0,
-                });
-            }
+            updateScene(generated.scene);
 
             return {
-                scene: generated.scene,
-                videoUrl: generated.videoUrl,
-                attempts: version,
-                finalScore: 1.0,
-                evaluation: null,
-                acceptedAttempt: version
+                data: generated,
+                metadata: {
+                    model: videoModelName,
+                    attempts: version,
+                    acceptedAttempt: version
+                }
             };
         }
 
@@ -133,23 +130,13 @@ export class SceneGeneratorAgent {
             characterReferenceImages,
             locationReferenceImages,
             generateAudio,
-            onComplete,
-            onProgress,
-            onRetry,
+            saveAssets,
+            updateScene,
+            onAttempt,
+            saveMetric,
             generationRules,
         );
 
-        this.assetManager.createVersionedAssets(
-            { projectId: scene.projectId, sceneId: scene.id },
-            'scene_video',
-            'video',
-            [ generationResultWithEvaluation.videoUrl || "" ],
-            {
-                model: videoModelName,
-                evaluation: generationResultWithEvaluation.evaluation,
-            },
-        );
-
         return generationResultWithEvaluation;
     }
 
@@ -169,15 +156,17 @@ export class SceneGeneratorAgent {
         characterReferenceImages?: string[],
         locationReferenceImages?: string[],
         generateAudio = false,
-        onAttemptComplete?: OnCompleteCallback<Scene>,
-        onProgress?: OnProgressCallback<Scene>,
-        onRetry?: (attempt: number) => Promise<number>,
+        saveAssets?: SaveAssetsCallback,
+        updateScene?: UpdateSceneCallback,
+        onAttempt?: OnAttemptCallback,
+        saveMetric?: GetAttemptMetricCallback,
         generationRules?: string[],
-    ): Promise<SceneGenerationResult> {
+    ): Promise<GenerativeResultEnvelope<SceneGenerationResult>> {
 
+        const startTime = Date.now();
         const acceptanceThreshold = this.qualityAgent.qualityConfig.minorIssueThreshold;
 
-        let bestScene: GeneratedScene | null = null;
+        let bestScene: Scene | null = null;
         let bestVideoUrl: string | null = null;
         let bestEvaluation: QualityEvaluationResult | null = null;
         let bestScore = 0;
@@ -188,8 +177,7 @@ export class SceneGeneratorAgent {
         for (let lastestAttempt = version + numAttempts; numAttempts <= this.qualityAgent.qualityConfig.maxRetries; numAttempts++) {
             totalAttempts = numAttempts;
             let evaluation: QualityEvaluationResult | null = null;
-            let score = 0;
-            let generated: { scene: GeneratedScene; videoUrl: string; } | null = null;
+            let generated: { scene: Scene; videoUrl: string; } | null = null;
             try {
 
                 generated = await this.generateSceneWithSafetyRetry(
@@ -203,8 +191,8 @@ export class SceneGeneratorAgent {
                     previousScene,
                     generateAudio,
                     generationRules,
-                    onProgress,
-                    onRetry,
+                    updateScene,
+                    onAttempt,
                 );
 
                 evaluation = await this.qualityAgent.evaluateScene(
@@ -215,38 +203,68 @@ export class SceneGeneratorAgent {
                     location,
                     lastestAttempt,
                     previousScene,
-                    onProgress,
+                    updateScene,
                     generationRules
                 );
 
-                score = this.qualityAgent[ "calculateOverallScore" ](evaluation.scores);
+                saveAssets?.(
+                    { projectId: scene.projectId, sceneId: scene.id },
+                    'scene_video',
+                    'video',
+                    [ generated.videoUrl ],
+                    {
+                        model: videoModelName,
+                        prompt: enhancedPrompt,
+                        evaluation: JSON.stringify(evaluation),
+                    },
+                );
+
+                saveMetric?.({
+                    assetKey: "scene_video",
+                    attemptNumber: lastestAttempt,
+                    finalScore: evaluation.score,
+                    ruleAdded: evaluation.promptCorrections?.map(c => c.correctedPromptSection)!,
+                    assetVersion: bestAttemptNumber,
+                    corrections: evaluation.promptCorrections!,
+                    startTime,
+                });
 
-                if (score > bestScore) {
-                    bestScore = score;
+                saveAssets?.(
+                    { projectId: scene.projectId, sceneId: scene.id },
+                    'scene_quality_evaluation',
+                    'text',
+                    [ JSON.stringify(evaluation) ],
+                    {
+                        model: qualityCheckModelName,
+                    },
+                );
+
+                if (evaluation.score > bestScore) {
+                    bestScore = evaluation.score;
                     bestScene = generated.scene;
                     bestVideoUrl = generated.videoUrl;
                     bestEvaluation = evaluation;
                 }
 
-                this.qualityAgent[ "logAttemptResult" ](numAttempts, score, evaluation.overall);
+                this.qualityAgent[ "logAttemptResult" ](numAttempts, evaluation.score, evaluation.grade);
 
-                if (score >= acceptanceThreshold) {
-                    console.log(`    Quality acceptable (${(score * 100).toFixed(1)}%)`);
+                if (evaluation.score >= acceptanceThreshold) {
+                    console.log(`    Quality acceptable (${(evaluation.score * 100).toFixed(1)}%)`);
 
-                    if (onAttemptComplete) {
-                        onAttemptComplete(generated.scene, {
-                            attemptNumber: lastestAttempt,
-                            finalScore: score,
-                        });
-                    }
+                    updateScene?.(generated.scene);
 
                     return {
-                        scene: generated.scene,
-                        videoUrl: generated.videoUrl,
-                        attempts: totalAttempts,
-                        finalScore: score,
-                        evaluation,
-                        acceptedAttempt: lastestAttempt
+                        data: {
+                            scene: generated.scene,
+                            videoUrl: generated.videoUrl,
+                            enhancedPrompt: enhancedPrompt,
+                        },
+                        metadata: {
+                            model: videoModelName,
+                            attempts: totalAttempts,
+                            evaluation,
+                            acceptedAttempt: lastestAttempt
+                        }
                     };
                 }
 
@@ -260,7 +278,7 @@ export class SceneGeneratorAgent {
                     scene,
                     characters,
                     lastestAttempt,
-                    onProgress
+                    updateScene,
                 );
 
                 await new Promise(resolve => setTimeout(resolve, 3000));
@@ -292,21 +310,31 @@ export class SceneGeneratorAgent {
             const thresholdPercent = (acceptanceThreshold * 100).toFixed(0);
             console.warn(`    Using best attempt: ${scorePercent}% (threshold: ${thresholdPercent}%)`);
 
-            if (onAttemptComplete) {
-                onAttemptComplete(bestScene, {
-                    attemptNumber: bestAttemptNumber,
-                    finalScore: bestScore,
-                });
-            }
+            updateScene?.(bestScene);
 
-            return {
-                scene: bestScene,
-                videoUrl: bestVideoUrl,
-                attempts: totalAttempts,
+            saveMetric?.({
+                assetKey: "scene_video",
+                attemptNumber: bestAttemptNumber,
                 finalScore: bestScore,
-                evaluation: bestEvaluation!,
-                warning: `Quality below threshold after ${totalAttempts} attempts`,
-                acceptedAttempt: bestAttemptNumber
+                ruleAdded: bestEvaluation?.promptCorrections?.map(c => c.correctedPromptSection)!,
+                assetVersion: bestAttemptNumber,
+                corrections: bestEvaluation?.promptCorrections!,
+                startTime,
+            });
+
+            return {
+                data: {
+                    scene: bestScene,
+                    videoUrl: bestVideoUrl,
+                    enhancedPrompt: enhancedPrompt,
+                },
+                metadata: {
+                    model: videoModelName,
+                    attempts: totalAttempts,
+                    evaluation: bestEvaluation!,
+                    warning: `Quality below threshold after ${totalAttempts} attempts`,
+                    acceptedAttempt: bestAttemptNumber
+                }
             };
         }
 
@@ -327,9 +355,11 @@ export class SceneGeneratorAgent {
         previousScene?: Scene,
         generateAudio = false,
         generationRules?: string[],
-        onProgress?: OnProgressCallback<Scene>,
-        onRetry?: (attempt: number) => Promise<number>,
-    ): Promise<{ scene: GeneratedScene, videoUrl: string }> {
+        updateScene?: UpdateSceneCallback,
+        onAttempt?: OnAttemptCallback,
+        saveMetric?: GetAttemptMetricCallback,
+    ): Promise<SceneGenerationResult> {
+
         console.log(`\n Generating Scene ${scene.id}: ${formatTime(scene.duration)}`);
         console.log(`   Duration: ${scene.duration}s | Shot: ${scene.shotType}`);
         const attemptLabel = version ? ` (Quality Attempt ${version})` : "";
@@ -348,7 +378,8 @@ export class SceneGeneratorAgent {
                 locationReferenceImages,
                 previousScene,
                 generateAudio,
-                onProgress
+                updateScene,
+                onAttempt
             ),
             {
                 prompt: finalPrompt,
@@ -366,7 +397,7 @@ export class SceneGeneratorAgent {
                 if (error instanceof RAIError) {
                     console.warn(`    Safety error ${attemptLabel}. Sanitizing...`);
                     const sanitizedPrompt = await this.qualityAgent.sanitizePrompt(params.prompt, error.message);
-                    attempt = await onRetry?.(attempt) || attempt;
+                    onAttempt?.(attempt);
                     return {
                         attempt,
                         params: {
@@ -379,10 +410,8 @@ export class SceneGeneratorAgent {
         );
 
         return {
-            scene: {
-                ...scene,
-                enhancedPrompt,
-            },
+            scene,
+            enhancedPrompt,
             videoUrl: generatedVideo
         };
     }
@@ -399,13 +428,14 @@ export class SceneGeneratorAgent {
         locationReferenceUrls?: string[],
         previousScene?: Scene,
         generateAudio = false,
-        onProgress?: OnProgressCallback<Scene>,
+        updateScene?: UpdateSceneCallback,
+        onAttempt?: OnAttemptCallback,
     ): Promise<string> {
 
         console.log(`   Generating video with prompt: ${prompt.substring(0, 50)}...`);
         scene.progressMessage = "Initializing video generation...";
         scene.status = "pending";
-        if (onProgress) onProgress(scene);
+        updateScene?.(scene);
 
         const outputMimeType = "video/mp4";
         const objectPath = this.storageManager.getObjectPath({ type: "scene_video", sceneId: sceneId, attempt: version });
@@ -481,7 +511,7 @@ export class SceneGeneratorAgent {
         console.log(`   ... Operation started: ${operation.name}`);
         scene.progressMessage = "Video generation in progress (remote)...";
         scene.status = "generating";
-        if (onProgress) onProgress(scene);
+        updateScene?.(scene);
 
         const SCENE_GEN_WAITTIME_MS = 10000;
         while (!operation.done) {
@@ -527,7 +557,7 @@ export class SceneGeneratorAgent {
 
         scene.progressMessage = "Video generated";
         scene.status = "complete";
-        if (onProgress) onProgress(scene);
+        updateScene?.(scene);
 
         return generatedVideo;
     }
diff --git a/src/workflow/agents/semantic-expert-agent.ts b/src/workflow/agents/semantic-expert-agent.ts
index 9f29857..b51618e 100644
--- a/src/workflow/agents/semantic-expert-agent.ts
+++ b/src/workflow/agents/semantic-expert-agent.ts
@@ -4,6 +4,7 @@ import { buildSemanticRulesPrompt } from "../prompts/semantic-rules-instruction"
 import { buildllmParams } from "../llm/google/google-llm-params";
 import { z } from "zod";
 import { qualityCheckModelName } from "../llm/google/models";
+import { GenerativeResultEnvelope, JobRecordSemanticAnalysis } from "@shared/types/job.types";
 
 const SemanticRuleSchema = z.object({
     category: z.string(),
@@ -21,10 +22,8 @@ export class SemanticExpertAgent {
         this.llm = llm;
     }
 
-    async generateRules(storyboard: Storyboard): Promise<string[]> {
+    async generateRules(storyboard: Storyboard): Promise<GenerativeResultEnvelope<JobRecordSemanticAnalysis[ 'result' ]>> {
         console.log("    SEMANTIC EXPERT: Analyzing storyboard for constraints...");
-
-        // Format context from storyboard
         const context = `
       Title: ${storyboard.metadata.title}
       Style: ${storyboard.metadata.style || 'Cinematic'}
@@ -48,7 +47,7 @@ export class SemanticExpertAgent {
 
             if (!response.text) {
                 console.warn("    Semantic Expert returned no text.");
-                return [];
+                return { data: { dynamicRules: [] }, metadata: { model: qualityCheckModelName, attempts: 1, acceptedAttempt: 1 } };
             }
 
             const data = JSON.parse(response.text);
@@ -56,12 +55,12 @@ export class SemanticExpertAgent {
 
             console.log(`    Generated ${parsed.rules.length} semantic constraints.`);
 
-            // Return just the rule strings
-            return parsed.rules.map(r => r.rule);
+            const dynamicRules = parsed.rules.map(r => r.rule);
+            return { data: { dynamicRules }, metadata: { model: qualityCheckModelName, attempts: 1, acceptedAttempt: 1 } };
 
         } catch (error) {
             console.error("    Failed to generate semantic rules:", error);
-            return []; // Fail gracefully (empty array means no *extra* rules)
+            return { data: { dynamicRules: [] }, metadata: { model: qualityCheckModelName, attempts: 1, acceptedAttempt: 1 } }; 
         }
     }
 }
diff --git a/src/workflow/asset-version-manager.ts b/src/workflow/asset-version-manager.ts
index 877af31..4d29788 100644
--- a/src/workflow/asset-version-manager.ts
+++ b/src/workflow/asset-version-manager.ts
@@ -82,7 +82,7 @@ export class AssetVersionManager {
                 type: specificType,
                 data,
                 metadata: specificMetadata,
-                createdAt: new Date().toISOString()
+                createdAt: new Date(),
             };
 
             history.head = newVersionNum;
diff --git a/src/workflow/dispatcher.ts b/src/workflow/dispatcher.ts
new file mode 100644
index 0000000..2458015
--- /dev/null
+++ b/src/workflow/dispatcher.ts
@@ -0,0 +1,191 @@
+// src/workflow/graph.ts
+import * as dotenv from "dotenv";
+dotenv.config();
+import { StateGraph, END, START, NodeInterrupt, Command, interrupt, Send } from "@langchain/langgraph";
+import { JobEvent, JobRecord, JobType } from "../shared/types/job.types";
+import {
+    AssetKey,
+    LlmRetryInterruptValue,
+} from "../shared/types/workflow.types";
+import { JobControlPlane } from "src/pipeline/services/job-control-plane";
+
+
+
+export type JobPayload<T = JobType> =
+    Extract<JobRecord, { type: T; }>[ 'payload' ] extends undefined
+    ? [ payload?: undefined ]
+    : [ payload: Extract<JobRecord, { type: T; }>[ 'payload' ] ];
+
+export type BatchJobs<T extends JobType = JobType> = (
+    Pick<Extract<JobRecord, { type: T; }>, "type" | "uniqueKey" | "assetKey">
+    & { payload: JobPayload<T>[ 0 ]; }
+)[];
+
+export class Dispatcher {
+
+    constructor(
+        private projectId: string,
+        private MAX_PARALLEL_JOBS: number,
+        private jobControlPlane: JobControlPlane,
+    ) { }
+
+    async ensureJob<T extends JobType>(
+        nodeName: string,
+        jobType: T,
+        // payload: Extract<JobRecord, { type: T; }>[ 'payload' ],
+        assetKey: AssetKey,
+        ...payloadArg: JobPayload<T>
+    ): Promise<{ jobId: string; } & Extract<JobRecord, { type: T; }>[ 'result' ] | undefined> {
+
+        const [ payload ] = payloadArg;
+        // 1. Fetch the latest job for this project + type + logic scoping
+        // We use nodeName as the uniqueKey for singleton jobs to ensure they are addressed correctly.
+        const job = await this.jobControlPlane.getLatestJob(this.projectId, jobType, nodeName);
+
+        // use the nodeName/uniqueKey for logical lookup.
+        const logicalKey = nodeName;
+
+        const interruptValue: LlmRetryInterruptValue = {
+            type: "waiting_for_job",
+            error: "waiting_for_job",
+            errorDetails: { jobId: job?.id, logicalKey },
+            functionName: "ensureJob",
+            nodeName,
+            projectId: this.projectId,
+            attempt: job?.attempt || 1,
+            lastAttemptTimestamp: new Date().toISOString(),
+        };
+
+        if (!job) {
+            // 3. Create initial job if none exists
+            // We omit the 'id' to let it generate a random uuidv7 PK.
+            // The 'uniqueKey' is our stable address for find/recover.
+            await this.jobControlPlane.createJob({
+                type: jobType,
+                projectId: this.projectId,
+                payload,
+                uniqueKey: nodeName,
+                assetKey: assetKey,
+            });
+            console.log(`[${nodeName}] Dispatched job for ${nodeName}`);
+            interrupt(interruptValue);
+        }
+
+        // 4. Handle existing job states
+        if (job?.state === 'COMPLETED') {
+            const result = job.result as any;
+            if (!result) {
+                throw new Error(`Job ${job.id} complete but no result was returned.`);
+            }
+            return { ...result, jobId: job.id };
+        }
+
+        if (job?.state === 'FAILED') {
+            // 5. Normal Retry: If failed but we have retries left, requeue the SAME record
+            if (job.attempt < job.maxRetries) {
+                console.log(`[${nodeName}] Job ${job.id} failed (Attempt ${job.attempt}/${job.maxRetries}). Requeueing...`);
+                await this.jobControlPlane.requeueJob(job.id, job.attempt, 'BACKOFF_RETRY');
+                interrupt(interruptValue);
+            }
+
+            // 6. Option 2 "Way Through": If we are here, retries are exhausted.
+            throw new Error(`Job ${job.id} failed and exhausted all ${job.maxRetries} retries. To reset, a new job record with the same uniqueKey must be created.`);
+        }
+
+        // Still RUNNING, CREATED, or other non-terminal states
+        interrupt(interruptValue);
+    }
+
+    async ensureBatchJobs<T extends JobType>(
+        nodeName: string,
+        jobs: BatchJobs<T>,
+    ): Promise<NonNullable<{ jobId: string; } & Extract<JobRecord, { type: T; }>[ 'result' ]>[]> {
+
+        const results: NonNullable<{ jobId: string; } & Extract<JobRecord, { type: T; }>[ 'result' ]>[] = [];
+        const missingJobs: typeof jobs = [];
+        const failedJobs: { id: string; attempt: number; error: string; }[] = [];
+        let runningCount = 0;
+
+        // 1. Check status of all requested jobs using 'getLatestJob' for logical addressing
+        for (const jobRequest of jobs) {
+            // For batch jobs, we treat the 'id' field as the uniqueKey (the logical address)
+            const job = await this.jobControlPlane.getLatestJob(this.projectId, jobRequest.type, jobRequest.uniqueKey);
+
+            if (!job) {
+                missingJobs.push(jobRequest);
+            } else if (job.state === 'COMPLETED') {
+                if (!job.result) throw new Error(`Job ${job.id} has no result object`);
+                results.push(job.result as any);
+            } else if (job.state === 'FAILED') {
+                failedJobs.push({ id: job.id, attempt: job.attempt, error: job.error || "Unknown error" });
+            } else {
+                // PENDING or RUNNING
+                runningCount++;
+            }
+        }
+
+        // 2. Handle Aggregated Failures
+        if (failedJobs.length > 0) {
+            const errorMsg = `${failedJobs.length} jobs failed in batch: ${failedJobs.map(f => f.id).join(', ')}`;
+            console.error(`[${nodeName}] ${errorMsg}`);
+
+            // aggregated failure interrupt
+            const interruptValue: LlmRetryInterruptValue = {
+                type: "llm_retry_exhausted",
+                error: errorMsg,
+                errorDetails: { failedJobs },
+                functionName: "ensureBatchJobs",
+                nodeName: nodeName,
+                projectId: this.projectId,
+                params: {
+                    jobIds: failedJobs.map(f => f.id)
+                },
+                attempt: failedJobs[ 0 ].attempt,
+                lastAttemptTimestamp: new Date().toISOString(),
+            };
+
+            interrupt(interruptValue);
+        }
+
+        // 3. Throttling & Creation
+        const slotsAvailable = this.MAX_PARALLEL_JOBS - runningCount;
+
+        if (missingJobs.length > 0) {
+            // Only start as many as we have slots for
+            const jobsToStart = missingJobs.slice(0, slotsAvailable);
+
+            if (jobsToStart.length > 0) {
+                console.log(`[${nodeName}] Starting ${jobsToStart.length} new jobs (Throttling: ${runningCount}/${this.MAX_PARALLEL_JOBS} active)`);
+
+                for (const jobRequest of jobsToStart) {
+                    await this.jobControlPlane.createJob({
+                        ...jobRequest,
+                        projectId: this.projectId,
+                        uniqueKey: jobRequest.uniqueKey,
+                    });
+                    runningCount++;
+                }
+            }
+        }
+
+        // 4. Wait if any are running or if we still have missing jobs (queued)
+        const notCompletedCount = jobs.length - results.length;
+
+        if (notCompletedCount > 0) {
+            console.log(`[${nodeName}] Waiting for ${notCompletedCount} jobs (${runningCount} running, ${jobs.length - results.length - runningCount} pending start)...`);
+            const interruptValue: LlmRetryInterruptValue = {
+                type: "waiting_for_batch",
+                error: `Waiting for ${notCompletedCount} batch jobs to complete`,
+                errorDetails: { pendingJobs: notCompletedCount },
+                functionName: "ensureBatchJobs",
+                nodeName: nodeName,
+                projectId: this.projectId,
+                attempt: 1, // TODO Possibly fix this if it adds value for the user
+                lastAttemptTimestamp: new Date().toISOString(),
+            };
+            interrupt(interruptValue);
+        }
+
+        return results as any;
+    }
+}
\ No newline at end of file
diff --git a/src/workflow/graph.ts b/src/workflow/graph.ts
index c7c8704..8697483 100644
--- a/src/workflow/graph.ts
+++ b/src/workflow/graph.ts
@@ -1,7 +1,7 @@
 // src/workflow/graph.ts
 import * as dotenv from "dotenv";
 dotenv.config();
-import { StateGraph, END, START, NodeInterrupt, Command, interrupt } from "@langchain/langgraph";
+import { StateGraph, END, START, NodeInterrupt, Command, interrupt, Send } from "@langchain/langgraph";
 import { JobControlPlane } from "../pipeline/services/job-control-plane";
 import { PoolManager } from "../pipeline/services/pool-manager";
 import { DistributedLockManager } from "../pipeline/services/lock-manager";
@@ -18,7 +18,6 @@ import {
   WorkflowState,
 } from "../shared/types/workflow.types";
 import { PipelineEvent } from "../shared/types/pipeline.types";
-import { z } from "zod";
 import { GCPStorageManager } from "./storage-manager";
 import { TextModelController } from "./llm/text-model-controller";
 import { VideoModelController } from "./llm/video-model-controller";
@@ -31,17 +30,18 @@ import { CheckpointerManager } from "./checkpointer-manager";
 import { RunnableConfig } from "@langchain/core/runnables";
 import { ProjectRepository } from "../pipeline/project-repository";
 import { AudioProcessingAgent } from "./agents/audio-processing-agent";
-import { CompositionalAgent } from "./agents/compositional-agent";
 import { FrameCompositionAgent } from "./agents/frame-composition-agent";
-import { SceneGeneratorAgent } from "./agents/scene-generator";
 import { ContinuityManagerAgent } from "./agents/continuity-manager";
-import { SemanticExpertAgent } from "./agents/semantic-expert-agent";
 import { PubSub } from "@google-cloud/pubsub";
 import { JOB_EVENTS_TOPIC_NAME } from "@shared/constants";
 import { AssetVersionManager } from "./asset-version-manager";
 import { MediaController } from "./media-controller";
 import { extractGenerationRules } from "./prompts/prompt-composer";
 import { errorHandler } from "./nodes/error-handler";
+import * as fs from 'node:fs/promises';
+import * as path from 'node:path';
+import { BatchJobs, Dispatcher } from "./dispatcher";
+import { interceptNodeInterruptAndThrow } from "@shared/utils/errors";
 
 
 
@@ -50,16 +50,6 @@ import { errorHandler } from "./nodes/error-handler";
 // Google Vertex AI + LangGraph + GCP Storage
 // ============================================================================
 
-type JobPayload<T = JobType> =
-  Extract<JobRecord, { type: T; }>[ 'payload' ] extends undefined
-  ? [ payload?: undefined ]
-  : [ payload: Extract<JobRecord, { type: T; }>[ 'payload' ] ];
-
-type BatchJobs<T extends JobType = JobType> = (
-  Pick<Extract<JobRecord, { type: T; }>, "type" | "uniqueKey" | "assetKey">
-  & { payload: JobPayload<T>[ 0 ]; }
-)[];
-
 export class CinematicVideoWorkflow {
   public graph: StateGraph<WorkflowState>;
   private storageManager: GCPStorageManager;
@@ -67,20 +57,12 @@ export class CinematicVideoWorkflow {
   private lockManager: DistributedLockManager;
   private projectRepository: ProjectRepository;
   private assetManager: AssetVersionManager;
-
-  private audioProcessingAgent: AudioProcessingAgent;
-  private compositionalAgent: CompositionalAgent;
-  private qualityAgent: QualityCheckAgent;
-  private semanticExpert: SemanticExpertAgent;
-  private frameCompositionAgent: FrameCompositionAgent;
-  private sceneAgent: SceneGeneratorAgent;
-  private continuityAgent: ContinuityManagerAgent;
+  private dispatcher: Dispatcher;
 
   private gcpProjectId: string;
   private projectId: string;
   private bucketName: string;
   private controller?: AbortController;
-
   private MAX_PARALLEL_JOBS: number;
   private MAX_RETRIES: number;
 
@@ -111,58 +93,22 @@ export class CinematicVideoWorkflow {
     this.projectId = projectId;
     this.bucketName = bucketName;
     this.controller = controller;
+    this.MAX_PARALLEL_JOBS = Number(process.env.MAX_PARALLEL_JOBS) || 2;
+    this.MAX_RETRIES = Number(process.env.MAX_RETRIES) || 2;
+
     this.storageManager = new GCPStorageManager(this.gcpProjectId, this.projectId, this.bucketName);
     this.jobControlPlane = jobControlPlane;
     this.lockManager = lockManager;
     this.projectRepository = new ProjectRepository();
     this.assetManager = new AssetVersionManager(this.projectRepository);
+    this.dispatcher = new Dispatcher(this.projectId, this.MAX_PARALLEL_JOBS, this.jobControlPlane);
 
-    const textandImageModel = new TextModelController('google');
-    const videoModel = new VideoModelController('google');
-    const agentOptions = { signal: this.controller?.signal };
-
-    this.audioProcessingAgent = new AudioProcessingAgent(
-      textandImageModel,
-      this.storageManager,
-      new MediaController(this.storageManager),
-      agentOptions
-    );
-
-    this.compositionalAgent = new CompositionalAgent(textandImageModel, this.storageManager, this.assetManager, agentOptions);
-
-    this.qualityAgent = new QualityCheckAgent(textandImageModel, this.storageManager, agentOptions);
-
-    this.semanticExpert = new SemanticExpertAgent(textandImageModel);
-
-    this.frameCompositionAgent = new FrameCompositionAgent(
-      textandImageModel,
-      textandImageModel,
-      this.qualityAgent,
-      this.storageManager,
-      this.assetManager,
-      agentOptions
-    );
-
-    this.sceneAgent = new SceneGeneratorAgent(
-      videoModel,
-      this.qualityAgent,
-      this.storageManager,
-      this.assetManager,
-      agentOptions
-    );
-
-    this.continuityAgent = new ContinuityManagerAgent(
-      textandImageModel,
-      textandImageModel,
-      this.frameCompositionAgent,
-      this.qualityAgent,
-      this.storageManager,
-      this.assetManager,
-      agentOptions
-    );
-
-    this.MAX_PARALLEL_JOBS = Number(process.env.MAX_PARALLEL_JOBS) || 2;
-    this.MAX_RETRIES = this.qualityAgent.qualityConfig.maxRetries;
+    // this.audioProcessingAgent = new AudioProcessingAgent(
+    //   textandImageModel,
+    //   this.storageManager,
+    //   new MediaController(this.storageManager),
+    //   agentOptions
+    // );
 
     this.graph = this.buildGraph();
   }
@@ -170,7 +116,7 @@ export class CinematicVideoWorkflow {
   public publishEvent: (event: PipelineEvent) => Promise<void> = async () => { };
 
   private async publishStateUpdate(project: Project | InitialProject, nodeName: string) {
-    await this.publishEvent({
+    this.publishEvent({
       type: "FULL_STATE",
       projectId: this.projectId,
       payload: { project },
@@ -179,166 +125,6 @@ export class CinematicVideoWorkflow {
     console.log(` Updated project after ${nodeName}`);
   }
 
-  private async ensureJob<T extends JobType>(
-    nodeName: string,
-    jobType: T,
-    // payload: Extract<JobRecord, { type: T; }>[ 'payload' ],
-    assetKey: AssetKey,
-    ...payloadArg: JobPayload<T>
-  ): Promise<{ jobId: string; } & Extract<JobRecord, { type: T; }>[ 'result' ] | undefined> {
-
-    const [ payload ] = payloadArg;
-    // 1. Fetch the latest job for this project + type + logic scoping
-    // We use nodeName as the uniqueKey for singleton jobs to ensure they are addressed correctly.
-    const job = await this.jobControlPlane.getLatestJob(this.projectId, jobType, nodeName);
-
-    // use the nodeName/uniqueKey for logical lookup.
-    const logicalKey = nodeName;
-
-    const interruptValue: LlmRetryInterruptValue = {
-      type: "waiting_for_job",
-      error: "waiting_for_job",
-      errorDetails: { jobId: job?.id, logicalKey },
-      functionName: "ensureJob",
-      nodeName,
-      projectId: this.projectId,
-      attempt: job?.attempt || 1,
-      lastAttemptTimestamp: new Date().toISOString(),
-    };
-
-    if (!job) {
-      // 3. Create initial job if none exists
-      // We omit the 'id' to let it generate a random uuidv7 PK.
-      // The 'uniqueKey' is our stable address for find/recover.
-      await this.jobControlPlane.createJob({
-        type: jobType,
-        projectId: this.projectId,
-        payload,
-        uniqueKey: nodeName,
-        assetKey: assetKey,
-      });
-      console.log(`[${nodeName}] Dispatched job for ${nodeName}`);
-      interrupt(interruptValue);
-    }
-
-    // 4. Handle existing job states
-    if (job?.state === 'COMPLETED') {
-      const result = job.result as any;
-      if (!result) {
-          throw new Error(`Job ${job.id} complete but no result was returned.`);
-        }
-      return { ...result, jobId: job.id };
-    }
-
-    if (job?.state === 'FAILED') {
-      // 5. Normal Retry: If failed but we have retries left, requeue the SAME record
-      if (job.attempt < job.maxRetries) {
-        console.log(`[${nodeName}] Job ${job.id} failed (Attempt ${job.attempt}/${job.maxRetries}). Requeueing...`);
-        await this.jobControlPlane.requeueJob(job.id, job.attempt, 'BACKOFF_RETRY');
-        interrupt(interruptValue);
-      }
-
-      // 6. Option 2 "Way Through": If we are here, retries are exhausted.
-      throw new Error(`Job ${job.id} failed and exhausted all ${job.maxRetries} retries. To reset, a new job record with the same uniqueKey must be created.`);
-    }
-
-    // Still RUNNING, CREATED, or other non-terminal states
-    interrupt(interruptValue);
-  }
-
-  private async ensureBatchJobs<T extends JobType>(
-    nodeName: string,
-    jobs: BatchJobs<T>,
-  ): Promise<NonNullable<{ jobId: string; } & Extract<JobRecord, { type: T; }>[ 'result' ]>[]> {
-
-    const results: NonNullable<{ jobId: string; } & Extract<JobRecord, { type: T; }>[ 'result' ]>[] = [];
-    const missingJobs: typeof jobs = [];
-    const failedJobs: { id: string; attempt: number; error: string; }[] = [];
-    let runningCount = 0;
-
-    // 1. Check status of all requested jobs using 'getLatestJob' for logical addressing
-    for (const jobRequest of jobs) {
-      // For batch jobs, we treat the 'id' field as the uniqueKey (the logical address)
-      const job = await this.jobControlPlane.getLatestJob(this.projectId, jobRequest.type, jobRequest.uniqueKey);
-
-      if (!job) {
-        missingJobs.push(jobRequest);
-      } else if (job.state === 'COMPLETED') {
-        if (!job.result) throw new Error(`Job ${job.id} has no result object`);
-        results.push(job.result as any);
-      } else if (job.state === 'FAILED') {
-        failedJobs.push({ id: job.id, attempt: job.attempt, error: job.error || "Unknown error" });
-      } else {
-        // PENDING or RUNNING
-        runningCount++;
-      }
-    }
-
-    // 2. Handle Aggregated Failures
-    if (failedJobs.length > 0) {
-      const errorMsg = `${failedJobs.length} jobs failed in batch: ${failedJobs.map(f => f.id).join(', ')}`;
-      console.error(`[${nodeName}] ${errorMsg}`);
-
-      // aggregated failure interrupt
-      const interruptValue: LlmRetryInterruptValue = {
-        type: "llm_retry_exhausted",
-        error: errorMsg,
-        errorDetails: { failedJobs },
-        functionName: "ensureBatchJobs",
-        nodeName: nodeName,
-        projectId: this.projectId,
-        params: {
-          jobIds: failedJobs.map(f => f.id)
-        },
-        attempt: failedJobs[ 0 ].attempt,
-        lastAttemptTimestamp: new Date().toISOString(),
-      };
-
-      interrupt(interruptValue);
-    }
-
-    // 3. Throttling & Creation
-    const slotsAvailable = this.MAX_PARALLEL_JOBS - runningCount;
-
-    if (missingJobs.length > 0) {
-      // Only start as many as we have slots for
-      const jobsToStart = missingJobs.slice(0, slotsAvailable);
-
-      if (jobsToStart.length > 0) {
-        console.log(`[${nodeName}] Starting ${jobsToStart.length} new jobs (Throttling: ${runningCount}/${this.MAX_PARALLEL_JOBS} active)`);
-
-        for (const jobRequest of jobsToStart) {
-          await this.jobControlPlane.createJob({
-            ...jobRequest,
-            projectId: this.projectId,
-            uniqueKey: jobRequest.uniqueKey, 
-          });
-          runningCount++;
-        }
-      }
-    }
-
-    // 4. Wait if any are running or if we still have missing jobs (queued)
-    const notCompletedCount = jobs.length - results.length;
-
-    if (notCompletedCount > 0) {
-      console.log(`[${nodeName}] Waiting for ${notCompletedCount} jobs (${runningCount} running, ${jobs.length - results.length - runningCount} pending start)...`);
-      const interruptValue: LlmRetryInterruptValue = {
-        type: "waiting_for_batch",
-        error: `Waiting for ${notCompletedCount} batch jobs to complete`,
-        errorDetails: { pendingJobs: notCompletedCount },
-        functionName: "ensureBatchJobs",
-        nodeName: nodeName,
-        projectId: this.projectId,
-        attempt: 1, // TODO Possibly fix this if it adds value for the user
-        lastAttemptTimestamp: new Date().toISOString(),
-      };
-      interrupt(interruptValue);
-    }
-
-    return results as any;
-  }
-
   private buildGraph(): StateGraph<WorkflowState> {
     const workflow = new StateGraph<WorkflowState>({
       channels: {
@@ -378,14 +164,17 @@ export class CinematicVideoWorkflow {
         console.log(" [Cinematic-Canvas]: Resuming from 'process_scene'");
         return "process_scene";
       }
+
       if (project.storyboard?.scenes?.length > 0) {
         if (project.generationRules.length > 0) {
           console.log("[Cinematic-Canvas]: Proceeding to 'generate_character_assets'");
           return "generate_character_assets";
         }
+
         console.log("[Cinematic-Canvas]: Proceeding to 'semantic_analysis'");
         return "semantic_analysis";
       }
+
       console.log("[Cinematic-Canvas]: Proceeding to 'expand_creative_prompt'");
       return "expand_creative_prompt";
     });
@@ -403,31 +192,31 @@ export class CinematicVideoWorkflow {
       if (executionMode === 'SEQUENTIAL') {
         if (state.currentSceneIndex < (scenes.length || 0)) {
           console.log("[process_scene edge]: Looping 'process_scene'");
-          return "process_scene";
+          return new Send("process_scene", state);
         }
       } else {
         const hasPending = scenes.some(s => s.status === 'pending');
         if (hasPending) {
           console.log("[process_scene edge]: Pending scenes found, looping 'process_scene'");
-          return "process_scene";
+          return new Send("process_scene", state);
         }
       }
       console.log("[process_scene edge]: Proceeding to 'render_video'");
-      return "render_video";
+      return new Send("render_video", state);
     });
     workflow.addEdge("render_video" as any, "finalize" as any);
     workflow.addEdge("finalize" as any, END);
 
-    workflow.addEdge("expand_creative_prompt" as any, "error_handler" as any);
-    workflow.addEdge("generate_storyboard_exclusively_from_prompt" as any, "error_handler" as any);
-    workflow.addEdge("create_scenes_from_audio" as any, "error_handler" as any);
-    workflow.addEdge("enrich_storyboard_and_scenes" as any, "error_handler" as any);
-    workflow.addEdge("semantic_analysis" as any, "error_handler" as any);
-    workflow.addEdge("generate_character_assets" as any, "error_handler" as any);
-    workflow.addEdge("generate_location_assets" as any, "error_handler" as any);
-    workflow.addEdge("generate_scene_assets" as any, "error_handler" as any);
-    workflow.addEdge("process_scene" as any, "error_handler" as any);
-    workflow.addEdge("render_video" as any, "error_handler" as any);
+    // workflow.addEdge("expand_creative_prompt" as any, "error_handler" as any);
+    // workflow.addEdge("generate_storyboard_exclusively_from_prompt" as any, "error_handler" as any);
+    // workflow.addEdge("create_scenes_from_audio" as any, "error_handler" as any);
+    // workflow.addEdge("enrich_storyboard_and_scenes" as any, "error_handler" as any);
+    // workflow.addEdge("semantic_analysis" as any, "error_handler" as any);
+    // workflow.addEdge("generate_character_assets" as any, "error_handler" as any);
+    // workflow.addEdge("generate_location_assets" as any, "error_handler" as any);
+    // workflow.addEdge("generate_scene_assets" as any, "error_handler" as any);
+    // workflow.addEdge("process_scene" as any, "error_handler" as any);
+    // workflow.addEdge("render_video" as any, "error_handler" as any);
 
     workflow.addNode("expand_creative_prompt", async (state: WorkflowState) => {
       const nodeName = "expand_creative_prompt";
@@ -435,9 +224,9 @@ export class CinematicVideoWorkflow {
       const project = await this.projectRepository.getProject(state.projectId);
       if (!project.metadata.initialPrompt) throw new Error("No user prompt provided");
 
-      const currentAttempt = (state.nodeAttempts?.[ nodeName ] || 0) + 1;
       try {
-        const result = await this.ensureJob(
+
+        const result = await this.dispatcher.ensureJob(
           nodeName,
           "EXPAND_CREATIVE_PROMPT",
           'enhanced_prompt',
@@ -447,21 +236,18 @@ export class CinematicVideoWorkflow {
           },
         );
         const { expandedPrompt } = result!;
-        console.log(`    Expanded to ${expandedPrompt.length} characters of cinematic detail`);
 
-        const updated = await this.projectRepository.updateInitialProject(state.projectId, {
-          ...project,
-          metadata: { ...project.metadata, enhancedPrompt: expandedPrompt }
-        });
-        await this.publishStateUpdate(updated, nodeName);
-        console.log(`[${nodeName}]: Completed\n`);
+        console.log(` Expanded prompt: ${project.metadata.initialPrompt.length} to ${expandedPrompt.length} characters of cinematic detail`);
+
+        this.publishStateUpdate(project, nodeName);
+        console.log(`[${this.projectId}-${nodeName}]: Completed\n`);
 
         if (state.hasAudio) {
           console.log("[expand_creative_prompt edge]: Proceeding to 'create_scenes_from_audio'");
           return new Command({
             goto: "create_scenes_from_audio",
             update: {
-              initialProject: updated,
+              initialProject: project,
               __interrupt__: undefined,
               __interrupt_resolved__: false,
             }
@@ -469,29 +255,20 @@ export class CinematicVideoWorkflow {
         }
         console.log("[expand_creative_prompt edge]: Proceeding to 'generate_storyboard_exclusively_from_prompt'");
         return new Command({
-          goto: "generate_storyboard_exclusively_from_prompt",
+          goto: "generate_storyboard_exclusively_from_prompt", 
           update: {
-            initialProject: updated,
+            initialProject: project,
             __interrupt__: undefined,
             __interrupt_resolved__: false,
           }
         });
-      } catch (error: any) {
-        if (error instanceof NodeInterrupt) {
-          throw error;
-        }
 
-        console.error(`[${nodeName}] error`, { error });
-        return new Command({
-          goto: "error_handler",
-          update: {
-            nodeAttempts: { [ nodeName ]: currentAttempt },
-            errors: [ { node: nodeName, message: error?.message, value: error?.value, shouldRetry: true, timestamp: new Date().toISOString() } ]
-          }
-        });
+      } catch (error: any) {
+        const errorContext = JSON.parse(JSON.stringify(error?.message as string))?.[ 0 ]?.value || error?.message;
+        interceptNodeInterruptAndThrow(errorContext, nodeName, state.projectId, errorContext);
       }
     }, {
-      ends: [ "create_scenes_from_audio", "generate_storyboard_exclusively_from_prompt", "error_handler" ]
+      ends: [ "create_scenes_from_audio", "generate_storyboard_exclusively_from_prompt", ]
     });
 
     workflow.addNode("generate_storyboard_exclusively_from_prompt", async (state: WorkflowState) => {
@@ -500,9 +277,8 @@ export class CinematicVideoWorkflow {
       const project = state.initialProject;
       if (!project?.metadata.enhancedPrompt) throw new Error("No enhanced prompt available");
 
-      const currentAttempt = (state.nodeAttempts?.[ nodeName ] || 0) + 1;
       try {
-        const result =  await this.ensureJob(
+        await this.dispatcher.ensureJob(
           nodeName,
           "GENERATE_STORYBOARD",
           "storyboard",
@@ -511,45 +287,22 @@ export class CinematicVideoWorkflow {
             enhancedPrompt: project?.metadata.enhancedPrompt
           },
         );
-        const { storyboard, jobId } = result!;
-        const cleaned = deleteBogusUrlsStoryboard(storyboard);
 
-        await this.projectRepository.createScenes(state.projectId, cleaned.scenes);
-        await this.projectRepository.createCharacters(state.projectId, cleaned.characters);
-        await this.projectRepository.createLocations(state.projectId, cleaned.locations);
-        await this.assetManager.createVersionedAssets(
-          { projectId: this.projectId },
-          'storyboard',
-          'text',
-          [ JSON.stringify(storyboard) ],
-          { model: textModelName, jobId },
-          true
-        );
-        const updated = await this.projectRepository.updateInitialProject(this.projectId, { storyboard });
-        await this.publishStateUpdate(updated, nodeName);
+        this.publishStateUpdate(project, nodeName);
         console.log(`[${nodeName}]: Completed\n`);
+
         return {
           ...state,
-          initialProject: updated,
+          initialProject: project,
           __interrupt__: undefined,
           __interrupt_resolved__: false,
         };
       } catch (error: any) {
-        if (error instanceof NodeInterrupt) {
-          throw error;
-        }
-
-        console.error(`[${nodeName}] error`, { error });
-        return new Command({
-          goto: "error_handler",
-          update: {
-            nodeAttempts: { [ nodeName ]: currentAttempt },
-            errors: [ { node: nodeName, message: error?.message, value: error?.value, shouldRetry: true, timestamp: new Date().toISOString() } ]
-          }
-        });
+        const errorContext = JSON.parse(JSON.stringify(error?.message as string))?.[ 0 ]?.value || error?.message;
+        interceptNodeInterruptAndThrow(errorContext, nodeName, state.projectId, errorContext);
       }
     }, {
-      ends: [ "enrich_storyboard_and_scenes", "error_handler" ]
+      ends: [ "enrich_storyboard_and_scenes", ]
     });
 
     workflow.addNode("create_scenes_from_audio", async (state: WorkflowState) => {
@@ -562,7 +315,7 @@ export class CinematicVideoWorkflow {
       const currentAttempt = (state.nodeAttempts?.[ nodeName ] || 0) + 1;
       console.log(" Creating Timed Scenes from Audio...");
       try {
-        const result = await this.ensureJob(
+        await this.dispatcher.ensureJob(
           nodeName,
           "PROCESS_AUDIO_TO_SCENES",
           "audio_analysis",
@@ -571,58 +324,21 @@ export class CinematicVideoWorkflow {
             enhancedPrompt: project?.metadata.enhancedPrompt,
           },
         );
-        const { analysis: { segments, ...analysis }, jobId } = result!;
-        const metadata = {
-          ...project.metadata,
-          ...analysis,
-        };
 
-        let update = {
-          metadata,
-          scenes: segments as Scene[],
-          characters: [],
-          locations: [],
-          storyboard: {
-            metadata,
-            scenes: segments as Scene[],
-            characters: [],
-            locations: [],
-          },
-          status: "pending",
-        } as unknown as Project;
-        update = deleteBogusUrlsStoryboard(update) as Project;
-        const updated = await this.projectRepository.updateProject(state.projectId, update);
-        await this.assetManager.createVersionedAssets(
-          { projectId: this.projectId },
-          'storyboard',
-          'text',
-          [ JSON.stringify(updated.storyboard) ],
-          { model: textModelName, jobId }
-        );
-        await this.publishStateUpdate(updated, nodeName);
+        this.publishStateUpdate(project, nodeName);
         console.log(`[${nodeName}]: Completed\n`);
         return {
           ...state,
-          initialProject: updated,
+          initialProject: project,
           __interrupt__: undefined,
           __interrupt_resolved__: false,
         };
       } catch (error: any) {
-        if (error instanceof NodeInterrupt) {
-          throw error;
-        }
-
-        console.error(`[${nodeName}] error`, { error });
-        return new Command({
-          goto: "error_handler",
-          update: {
-            nodeAttempts: { [ nodeName ]: currentAttempt },
-            errors: [ { node: nodeName, message: error?.message, value: error?.value, shouldRetry: true, timestamp: new Date().toISOString() } ]
-          }
-        });
+        const errorContext = JSON.parse(JSON.stringify(error?.message as string))?.[ 0 ]?.value || error?.message;
+        interceptNodeInterruptAndThrow(errorContext, nodeName, state.projectId, errorContext);
       }
     }, {
-      ends: [ "enrich_storyboard_and_scenes", "error_handler" ]
+      ends: [ "enrich_storyboard_and_scenes", ]
     });
 
     workflow.addNode("enrich_storyboard_and_scenes", async (state: WorkflowState) => {  
@@ -635,7 +351,8 @@ export class CinematicVideoWorkflow {
       const currentAttempt = (state.nodeAttempts?.[ nodeName ] || 0) + 1;
       console.log(" Enhancing storyboard...");
       try {
-        const result = await this.ensureJob(
+
+        await this.dispatcher.ensureJob(
           nodeName,
           "ENHANCE_STORYBOARD",
           "storyboard",
@@ -644,59 +361,22 @@ export class CinematicVideoWorkflow {
             enhancedPrompt: project.metadata.enhancedPrompt
           },
         );
-        const { storyboard: rawStoryboard, jobId } = result!;
 
-        const storyboard = deleteBogusUrlsStoryboard(rawStoryboard as any);
-
-        let update = {
-          status: "pending",
-          metadata: storyboard.metadata,
-          scenes: storyboard.scenes,
-          characters: storyboard.characters,
-          locations: storyboard.locations,
-          storyboard: {
-            metadata: storyboard.metadata,
-            scenes: storyboard.scenes,
-            characters: storyboard.characters,
-            locations: storyboard.locations,
-          },
-        } as unknown as Project;
-        await this.projectRepository.createScenes(state.projectId, update.scenes);
-        await this.projectRepository.createCharacters(state.projectId, update.characters);
-        await this.projectRepository.createLocations(state.projectId, update.locations);
-        const updated = await this.projectRepository.updateProject(state.projectId, update);
-        await this.assetManager.createVersionedAssets(
-          { projectId: this.projectId },
-          'storyboard',
-          'text',
-          [ JSON.stringify(storyboard) ],
-          { model: textModelName, jobId: jobId }
-        );
-        await this.publishStateUpdate(updated, nodeName);
+        this.publishStateUpdate(project, nodeName);
         console.log(`[${nodeName}]: Completed\n`);
         return {
           ...state,
-          initialProject: updated,
-          project: updated, // full project is set
+          initialProject: project,
+          project: project,
           __interrupt__: undefined,
           __interrupt_resolved__: false,
         };
       } catch (error: any) {
-        if (error instanceof NodeInterrupt) {
-          throw error;
-        }
-
-        console.error(`[${nodeName}] error`, { error });
-        return new Command({
-          goto: "error_handler",
-          update: {
-            nodeAttempts: { [ nodeName ]: currentAttempt },
-            errors: [ { node: nodeName, message: error?.message, value: error?.value, shouldRetry: true, timestamp: new Date().toISOString() } ]
-          }
-        });
+        const errorContext = JSON.parse(JSON.stringify(error?.message as string))?.[ 0 ]?.value || error?.message;
+        interceptNodeInterruptAndThrow(errorContext, nodeName, state.projectId, errorContext);
       }
     }, {
-      ends: [ "semantic_analysis", "error_handler" ]
+      ends: [ "semantic_analysis",  ]
     });
 
     workflow.addNode("semantic_analysis", async (state: WorkflowState) => {
@@ -705,56 +385,30 @@ export class CinematicVideoWorkflow {
       const project = state.project;
       if (!project?.storyboard) throw new Error("No storyboard available.");
 
-      const currentAttempt = (state.nodeAttempts?.[ nodeName ] || 0) + 1;
-      console.log(" Semantic Rule Analysis...");
+      console.log(" Semantic Rule Analysis ");
       try {
-        const result = await this.ensureJob(
+        await this.dispatcher.ensureJob(
           nodeName,
           "SEMANTIC_ANALYSIS",
           "generation_rules",
         );
-        const { dynamicRules, jobId } = result!;
-        const proactiveRules = (await import("./prompts/generation-rules-presets")).getProactiveRules();
-        const uniqueRules = Array.from(new Set([ ...proactiveRules, ...dynamicRules ]));
-        console.log(` Rules Initialized: ${proactiveRules.length} Global, ${dynamicRules.length} Semantic.`);
-
-        const updated = await this.projectRepository.updateProject(this.projectId, {
-          ...project,
-          generationRules: uniqueRules,
-          generationRulesHistory: [ ...project.generationRulesHistory, uniqueRules ]
-        });
-        await this.publishStateUpdate(updated, nodeName);
-        await this.assetManager.createVersionedAssets(
-          { projectId: this.projectId },
-          'generation_rules',
-          'text',
-          [ JSON.stringify(uniqueRules) ],
-          { model: textModelName, jobId: jobId }
-        );
+
+        this.publishStateUpdate(project, nodeName);
+
         console.log(`[${nodeName}]: Completed\n`);
         return {
           ...state,
-          initialProject: updated,
-          project: updated,
+          initialProject: project,
+          project: project,
           __interrupt__: undefined,
           __interrupt_resolved__: false,
         };
       } catch (error: any) {
-        if (error instanceof NodeInterrupt) {
-          throw error;
-        }
-
-        console.error(`[${nodeName}] error`, { error });
-        return new Command({
-          goto: "error_handler",
-          update: {
-            nodeAttempts: { [ nodeName ]: currentAttempt },
-            errors: [ { node: nodeName, message: error?.message, value: error?.value, shouldRetry: true, timestamp: new Date().toISOString() } ]
-          }
-        });
+        const errorContext = JSON.parse(JSON.stringify(error?.message as string))?.[ 0 ]?.value || error?.message;
+        interceptNodeInterruptAndThrow(errorContext, nodeName, state.projectId, errorContext);
       }
     }, {
-      ends: [ "generate_character_assets", "error_handler" ]
+      ends: [ "generate_character_assets",  ]
     });
 
     workflow.addNode("generate_character_assets", async (state: WorkflowState) => {
@@ -763,8 +417,7 @@ export class CinematicVideoWorkflow {
       let project = state.project;
       if (!project?.storyboard) throw new Error("No project storyboard available");
 
-      const currentAttempt = (state.nodeAttempts?.[ nodeName ] || 0) + 1;
-      console.log(` Generating Character References...Attempt ${currentAttempt}`);
+      console.log(` Generating Character References `);
       try {
         const executionMode = process.env.EXECUTION_MODE || 'SEQUENTIAL';
         console.log(`[${nodeName}]: Executing in ${executionMode.toLowerCase()} mode.`);
@@ -773,7 +426,7 @@ export class CinematicVideoWorkflow {
 
         let updatedProject: Project;
         if (executionMode === 'SEQUENTIAL') {
-          const result = await this.ensureJob(
+          await this.dispatcher.ensureJob(
             nodeName,
             "GENERATE_CHARACTER_ASSETS",
             "character_image",
@@ -782,105 +435,89 @@ export class CinematicVideoWorkflow {
               generationRules: project.generationRules,
             },
           );
-          const { characters: updatedChars, jobId } = result!;
-
-          const updated = await this.projectRepository.updateCharacters(updatedChars);
-          const characterIds: string[] = [];
-          const characterImageUris: string[] = [];
-          updated.forEach((char) => {
-            characterIds.push(char.id);
-            const assets = getAllBestFromAssets(char.assets);
-            characterImageUris.push(assets[ 'character_image' ]?.data || "");
-          });
-          if (characterIds.length > 0) {
-            await this.assetManager.createVersionedAssets(
-              { projectId: this.projectId, characterIds },
-              'character_image',
-              'image',
-              characterImageUris,
-              { model: imageModelName, jobId }
-            );
-          }
-          updatedProject = await this.projectRepository.getProjectFullState(state.projectId);
-          await this.publishStateUpdate(updatedProject, nodeName);
+
+          this.publishStateUpdate(project, nodeName);
 
         } else {
-          // Parallel logic (fan-out)
-          const characterIds = characters.map(c => c.id);
 
-          const jobs: BatchJobs<'GENERATE_CHARACTER_ASSETS'> = characters.map((char, index) => ({
-            uniqueKey: char.id,
-            type: "GENERATE_CHARACTER_ASSETS",
-            assetKey: "character_image",
-            payload: {
-              characters: [ char ],
+          await this.dispatcher.ensureJob(
+            nodeName,
+            "GENERATE_CHARACTER_ASSETS",
+            "character_image",
+            {
+              characters: characters,
               generationRules: project.generationRules,
             },
-          }));
-
-          const results = await this.ensureBatchJobs(nodeName, jobs);
-          const allUpdatedChars = results.flatMap(r => r.characters);
-          const updated = await this.projectRepository.updateCharacters(allUpdatedChars);
-
-          const charMap = new Map(updated.map(c => [ c.id, c ]));
-
-          const validIds: string[] = [];
-          const validUris: string[] = [];
-          const validMetadata: AssetVersion[ 'metadata' ][] = [];
-          const validTypes: AssetType[] = [];
-
-          characters.forEach(c => {
-            const updatedChar = charMap.get(c.id);
-            const assets = getAllBestFromAssets(updatedChar?.assets);
-            const imageData = assets[ 'character_image' ]?.data;
-
-            if (updatedChar && imageData) {
-              validIds.push(updatedChar.id);
-              validUris.push(imageData);
-              validTypes.push('image');
-              validMetadata.push({
-                model: imageModelName,
-                jobId: results.find(r => r.characters.some(rc => rc.id === c.id))?.jobId!,
-              });
-            }
-          });
-          if (validIds.length > 0) {
-            await this.assetManager.createVersionedAssets(
-              { projectId: this.projectId, characterIds: validIds },
-              'character_image',
-              validTypes,
-              validUris,
-              validMetadata,
-              true
-            );
-          }
-          updatedProject = await this.projectRepository.getProjectFullState(state.projectId);
-          await this.publishStateUpdate(updatedProject, nodeName);
+          );
+
+          this.publishStateUpdate(project, nodeName);
+
+          // Parallel logic (fan-out)
+          // const characterIds = characters.map(c => c.id);
+
+          // const jobs: BatchJobs<'GENERATE_CHARACTER_ASSETS'> = characters.map((char, index) => ({
+          //   uniqueKey: char.id,
+          //   type: "GENERATE_CHARACTER_ASSETS",
+          //   assetKey: "character_image",
+          //   payload: {
+          //     characters: [ char ],
+          //     generationRules: project.generationRules,
+          //   },
+          // }));
+
+          // const results = await this.dispatcher.ensureBatchJobs(nodeName, jobs);
+          // const allUpdatedChars = results.flatMap(r => r.characters);
+          // const updated = await this.projectRepository.updateCharacters(allUpdatedChars);
+
+          // const charMap = new Map(updated.map(c => [ c.id, c ]));
+
+          // const validIds: string[] = [];
+          // const validUris: string[] = [];
+          // const validMetadata: AssetVersion[ 'metadata' ][] = [];
+          // const validTypes: AssetType[] = [];
+
+          // characters.forEach(c => {
+          //   const updatedChar = charMap.get(c.id);
+          //   const assets = getAllBestFromAssets(updatedChar?.assets);
+          //   const imageData = assets[ 'character_image' ]?.data;
+
+          //   if (updatedChar && imageData) {
+          //     validIds.push(updatedChar.id);
+          //     validUris.push(imageData);
+          //     validTypes.push('image');
+          //     validMetadata.push({
+          //       model: imageModelName,
+          //       jobId: results.find(r => r.characters.some(rc => rc.id === c.id))?.jobId!,
+          //     });
+          //   }
+          // });
+          // if (validIds.length > 0) {
+          //   await this.assetManager.createVersionedAssets(
+          //     { projectId: this.projectId, characterIds: validIds },
+          //     'character_image',
+          //     validTypes,
+          //     validUris,
+          //     validMetadata,
+          //     true
+          //   );
+          // }
+          // updatedProject = await this.projectRepository.getProjectFullState(state.projectId);
+          // this.publishStateUpdate(updatedProject, nodeName);
         }
 
         console.log(`[${nodeName}]: Completed\n`);
         return {
           ...state,
-          project: updatedProject,
+          project,
           __interrupt__: undefined,
           __interrupt_resolved__: false,
         };
       } catch (error: any) {
-        if (error instanceof NodeInterrupt) {
-          throw error;
-        }
-
-        console.error(`[${nodeName}] error`, { error });
-        return new Command({
-          goto: "error_handler",
-          update: {
-            nodeAttempts: { [ nodeName ]: currentAttempt },
-            errors: [ { node: nodeName, message: error?.message, value: error?.value, shouldRetry: true, timestamp: new Date().toISOString() } ]
-          }
-        });
+        const errorContext = JSON.parse(JSON.stringify(error?.message as string))?.[ 0 ]?.value || error?.message;
+        interceptNodeInterruptAndThrow(errorContext, nodeName, state.projectId, errorContext);
       }
     }, {
-      ends: [ "generate_location_assets", "error_handler" ]
+      ends: [ "generate_location_assets",  ]
     });
 
     workflow.addNode("generate_location_assets", async (state: WorkflowState) => {
@@ -889,17 +526,14 @@ export class CinematicVideoWorkflow {
       let project = state.project;
       if (!project?.storyboard) throw new Error("No project storyboard available");
 
-      const currentAttempt = (state.nodeAttempts?.[ nodeName ] || 0) + 1;
-      console.log(` Generating Location References...Attempt ${currentAttempt}`);
-      let updatedProject: Project;
+      console.log(` Generating Location References `);
       try {
         const executionMode = process.env.EXECUTION_MODE || 'SEQUENTIAL';
         console.log(`[${nodeName}]: Executing in ${executionMode.toLowerCase()} mode.`);
         const locations = project.storyboard.locations;
-        const locationIds = locations.map(loc => loc.id);
 
         if (executionMode === 'SEQUENTIAL') {
-          const result = await this.ensureJob(
+          await this.dispatcher.ensureJob(
             nodeName,
             "GENERATE_LOCATION_ASSETS",
             "location_image",
@@ -908,101 +542,72 @@ export class CinematicVideoWorkflow {
               generationRules: project.generationRules,
             },
           );
-          const { locations: updatedLocs, jobId } = result!;
-
-          const updated = await this.projectRepository.updateLocations(updatedLocs);
-          const locationImageUris: string[] = [];
-          updated.forEach((loc) => {
-            const assets = getAllBestFromAssets(loc.assets);
-            if (assets[ 'location_image' ]?.data) {
-              locationImageUris.push(assets[ 'location_image' ].data);
-            }
-          });
-          if (locationIds.length > 0 && locationImageUris.length > 0) {
-            await this.assetManager.createVersionedAssets(
-              { projectId: this.projectId, locationIds },
-              'location_image',
-              'image',
-              locationImageUris,
-              { model: imageModelName, jobId }
-            );
-          }
-          updatedProject = await this.projectRepository.getProjectFullState(state.projectId);
-          await this.publishStateUpdate(updatedProject, nodeName);
+
+          this.publishStateUpdate(project, nodeName);
         } else {
 
-          const jobs: BatchJobs<"GENERATE_LOCATION_ASSETS"> = locations.map((loc, index) => ({
-            id: this.jobControlPlane.jobId(this.projectId, nodeName, `loc-${loc.id}`),
-            type: "GENERATE_LOCATION_ASSETS" as const,
-            assetKey: "location_image",
-            payload: {
-              locations: [ loc ],
-              generationRules: project.generationRules
+          await this.dispatcher.ensureJob(
+            nodeName,
+            "GENERATE_LOCATION_ASSETS",
+            "location_image",
+            {
+              locations: locations,
+              generationRules: project.generationRules,
             },
-          }));
-
-          const results = await this.ensureBatchJobs(nodeName, jobs);
-          const allUpdatedLocs = results.flatMap(r => r.locations);
-          const updated = await this.projectRepository.updateLocations(allUpdatedLocs);
-
-          const locMap = new Map(updated.map(l => [ l.id, l ]));
-
-          const validIds: string[] = [];
-          const validUris: string[] = [];
-          const validMetadata: AssetVersion[ 'metadata' ][] = [];
-          const validTypes: AssetType[] = [];
-
-          locations.forEach(l => {
-            const updatedLoc = locMap.get(l.id);
-            const assets = getAllBestFromAssets(updatedLoc?.assets);
-            const imageData = assets[ 'location_image' ]?.data;
-
-            if (updatedLoc && imageData) {
-              validIds.push(updatedLoc.id);
-              validUris.push(imageData);
-              validTypes.push('image');
-              validMetadata.push({
-                model: imageModelName,
-                jobId: results.find(r => r.locations.some(rl => rl.id === l.id))?.jobId!,
-              });
-            }
-          });
-          if (validIds.length > 0) {
-            await this.assetManager.createVersionedAssets(
-              { projectId: this.projectId, locationIds: validIds },
-              'location_image',
-              validTypes,
-              validUris,
-              validMetadata,
-              true
-            );
-          }
-          updatedProject = await this.projectRepository.getProjectFullState(state.projectId);
-          await this.publishStateUpdate(updatedProject, nodeName);
+          );
+
+          this.publishStateUpdate(project, nodeName);
+
+          // const jobs: BatchJobs<"GENERATE_LOCATION_ASSETS"> = locations.map((loc, index) => ({
+          //   id: this.jobControlPlane.jobId(this.projectId, nodeName, `loc-${loc.id}`),
+          //   type: "GENERATE_LOCATION_ASSETS" as const,
+          //   assetKey: "location_image",
+          //   payload: {
+          //     locations: [ loc ],
+          //     generationRules: project.generationRules
+          //   },
+          // }));
+
+          // const results = await this.dispatcher.ensureBatchJobs(nodeName, jobs);
+          // const allUpdatedLocs = results.flatMap(r => r.locations);
+          // const updated = await this.projectRepository.updateLocations(allUpdatedLocs);
+
+          // const locMap = new Map(updated.map(l => [ l.id, l ]));
+
+          // const validIds: string[] = [];
+          // const validUris: string[] = [];
+          // const validMetadata: AssetVersion[ 'metadata' ][] = [];
+          // const validTypes: AssetType[] = [];
+
+          // locations.forEach(l => {
+          //   const updatedLoc = locMap.get(l.id);
+          //   const assets = getAllBestFromAssets(updatedLoc?.assets);
+          //   const imageData = assets[ 'location_image' ]?.data;
+
+          //   if (updatedLoc && imageData) {
+          //     validIds.push(updatedLoc.id);
+          //     validUris.push(imageData);
+          //     validTypes.push('image');
+          //     validMetadata.push({
+          //       model: imageModelName,
+          //       jobId: results.find(r => r.locations.some(rl => rl.id === l.id))?.jobId!,
+          //     });
+          //   }
+          // });
         }
         console.log(`[${nodeName}]: Completed\n`);
         return {
           ...state,
-          project: updatedProject,
+          project,
           __interrupt__: undefined,
           __interrupt_resolved__: false,
         };
       } catch (error: any) {
-        if (error instanceof NodeInterrupt) {
-          throw error;
-        }
-
-        console.error(`[${nodeName}] error`, { error });
-        return new Command({
-          goto: "error_handler",
-          update: {
-            nodeAttempts: { [ nodeName ]: currentAttempt },
-            errors: [ { node: nodeName, message: error?.message, value: error?.value, shouldRetry: true, timestamp: new Date().toISOString() } ]
-          }
-        });
+        const errorContext = JSON.parse(JSON.stringify(error?.message as string))?.[ 0 ]?.value || error?.message;
+        interceptNodeInterruptAndThrow(errorContext, nodeName, state.projectId, errorContext);
       }
     }, {
-      ends: [ "generate_scene_assets", "error_handler" ]
+      ends: [ "generate_scene_assets", ]
     });
 
     workflow.addNode("generate_scene_assets", async (state: WorkflowState) => {
@@ -1014,89 +619,66 @@ export class CinematicVideoWorkflow {
       const currentAttempt = (state.nodeAttempts?.[ nodeName ] || 0) + 1;
       console.log(` Generating Scene Reference Images...Attempt ${currentAttempt}`);
       try {
-        const executionMode = process.env.EXECUTION_MODE || 'SEQUENTIAL';
-        console.log(`[${nodeName}]: Executing in ${executionMode.toLowerCase()} mode.`);
-        const scenes = await this.projectRepository.getProjectScenes(state.projectId);
+        // const executionMode = process.env.EXECUTION_MODE || 'SEQUENTIAL';
+        // console.log(`[${nodeName}]: Executing in ${executionMode.toLowerCase()} mode.`);
+        // const scenes = await this.projectRepository.getProjectScenes(state.projectId);
 
-        if (executionMode === 'SEQUENTIAL') {
-          for (const scene of scenes) {
-            const result = await this.ensureJob(
+        // if (executionMode === 'SEQUENTIAL') {
+        await this.dispatcher.ensureJob(
               nodeName,
               "GENERATE_SCENE_FRAMES",
               "scene_start_frame",
               {
-                sceneId: scene.id,
-                sceneIndex: scene.sceneIndex,
+                sceneId: "",
+                sceneIndex: 0,
               },
             );
 
-            if (result!.updatedScenes && result!.updatedScenes.length > 0) {
-              await this.projectRepository.updateScenes(result!.updatedScenes);
-            }
-          }
-
-          for (const scene of scenes) {
-            const result = await this.ensureJob(
+        await this.dispatcher.ensureJob(
               nodeName,
               "GENERATE_SCENE_FRAMES",
               "scene_end_frame",
               {
-                sceneId: scene.id,
-                sceneIndex: scene.sceneIndex,
+                sceneId: "",
+                sceneIndex: 0,
               },
             );
-
-            if (result!.updatedScenes && result!.updatedScenes.length > 0) {
-              await this.projectRepository.updateScenes(result!.updatedScenes);
-            }
-          }
-        } else {
-
-          const jobs = await Promise.all(scenes.flatMap((scene) => {
-            const assetKeys = [ "scene_start_frame", "scene_end_frame" ] as const;
-            return assetKeys.map(async (key) => {
-              return {
-                id: this.jobControlPlane.jobId(this.projectId, nodeName, `scene-${scene.id}-${key}`),
-                type: "GENERATE_SCENE_FRAMES" as const,
-                assetKey: key,
-                payload: {
-                  sceneId: scene.id,
-                  sceneIndex: scene.sceneIndex,
-                },
-              };
-            });
-          }));
-
-          const results = await this.ensureBatchJobs<"GENERATE_SCENE_FRAMES">(nodeName, jobs);
-          const allUpdatedScenes = results.flatMap(r => r.updatedScenes);
-          await this.projectRepository.updateScenes(allUpdatedScenes);
-        }
-
-        let updatedProject = await this.projectRepository.getProjectFullState(state.projectId);
-        await this.publishStateUpdate(updatedProject, nodeName);
+        // } else {
+
+        // const jobs = await Promise.all(scenes.flatMap((scene) => {
+        //   const assetKeys = [ "scene_start_frame", "scene_end_frame" ] as const;
+        //   return assetKeys.map(async (key) => {
+        //     return {
+        //       id: this.jobControlPlane.jobId(this.projectId, nodeName, `scene-${scene.id}-${key}`),
+        //       type: "GENERATE_SCENE_FRAMES" as const,
+        //       assetKey: key,
+        //       payload: {
+        //         sceneId: scene.id,
+        //         sceneIndex: scene.sceneIndex,
+        //       },
+        //     };
+        //   });
+        // }));
+
+        // const results = await this.dispatcher.ensureBatchJobs<"GENERATE_SCENE_FRAMES">(nodeName, jobs);
+        // const allUpdatedScenes = results.flatMap(r => r.updatedScenes);
+        // await this.projectRepository.updateScenes(allUpdatedScenes);
+        // }
+
+        this.publishStateUpdate(project, nodeName);
         console.log(`[${nodeName}]: Completed\n`);
         return {
           ...state,
-          project: updatedProject,
+          project,
           __interrupt__: undefined,
           __interrupt_resolved__: false,
         };
       } catch (error: any) {
-        if (error instanceof NodeInterrupt) {
-          throw error;
-        }
-
-        console.error(`[${nodeName}] error`, { error });
-        return new Command({
-          goto: "error_handler",
-          update: {
-            nodeAttempts: { [ nodeName ]: currentAttempt },
-            errors: [ { node: nodeName, message: error?.message, value: error?.value, shouldRetry: true, timestamp: new Date().toISOString() } ]
-          }
-        });
+        const errorContext = JSON.parse(JSON.stringify(error?.message as string))?.[ 0 ]?.value || error?.message;
+        interceptNodeInterruptAndThrow(errorContext, nodeName, state.projectId, errorContext);
       }
     }, {
-      ends: [ "process_scene", "error_handler" ]
+      ends: [ "process_scene", ]
     });
 
     workflow.addNode("process_scene", async (state: WorkflowState) => {
@@ -1107,19 +689,22 @@ export class CinematicVideoWorkflow {
       console.log(`[${nodeName}]: Processing Scene ${state.currentSceneIndex}. Executing in ${executionMode.toLowerCase()} mode. Attempt ${currentAttempt}`);
       let project = state.project;
       if (!project) throw new Error("No project state available");
+
       const { scenes } = project;
 
-      let updatedProject: Project;
       if (executionMode === 'SEQUENTIAL') {
         const index = state.currentSceneIndex;
         if (index >= scenes.length) return state;
 
         const scene = scenes[ index ];
         const nextScene = scenes[ index + 1 ];
+
         const [ best ] = await this.assetManager.getBestVersion({ projectId: this.projectId, sceneId: scene.id }, 'scene_video');
-        const videoUrl = best ? scene.assets[ 'scene_video' ]?.versions[ best.version ].data : null;
+        const videoUrl = best ? best.data : null;
+
         const forceRegenerateIndex = project.forceRegenerateSceneIds.findIndex(id => id === scene.id);
         const shouldForceRegenerate = forceRegenerateIndex !== -1;
+
         if (!shouldForceRegenerate && videoUrl && await this.storageManager.fileExists(videoUrl)) {
           console.log(`   ... Scene video already exists at ${videoUrl}, skipping.`);
           await this.publishEvent({
@@ -1136,25 +721,40 @@ export class CinematicVideoWorkflow {
           let shouldRenderScenes = false;
           const [ nextSceneBest ] = await this.assetManager.getBestVersion({ projectId: this.projectId, sceneId: nextScene.id }, 'scene_video');
           const nextScenePath = nextSceneBest ? await this.storageManager.getObjectPath({ type: "scene_video", sceneId: nextScene.id, attempt: nextSceneBest.version }) : "";
-          const nextExists = await this.storageManager.fileExists(nextScenePath);
-          if (!nextExists) {
+          const nextSceneVideoExists = await this.storageManager.fileExists(nextScenePath);
+          if (!nextSceneVideoExists) {
             shouldRenderScenes = true;
           } else {
             console.log(` ... Next scene (${nextScene.id}) also exists, skipping redundant stitch.`);
           }
-          if (!shouldRenderScenes) {
-            const renderedVideo = await this.audioProcessingAgent.mediaController.performIncrementalVideoRender(scenes, project.metadata.audioGcsUri, this.projectId, 1);
-            if (renderedVideo) { await this.assetManager.createVersionedAssets({ projectId: this.projectId }, 'render_video', 'video', [ renderedVideo ], { model: videoModelName, jobId: "" }); }
+
+          if (shouldRenderScenes) {
+            const videoPaths = scenes.map(s => {
+              const sceneVideoAssets = s.assets[ 'scene_video' ];
+              return sceneVideoAssets?.versions[ sceneVideoAssets.best ].data;
+            }).filter((uri): uri is string => !!uri);
+            if (videoPaths.length === 0) {
+              console.warn(`[${nodeName}]: No videos to render.`);
+              return state;
+            }
+
+            await this.dispatcher.ensureJob(
+              nodeName,
+              "RENDER_VIDEO",
+              "render_video",
+              {
+                videoPaths,
+                audioGcsUri: project.metadata.audioGcsUri,
+              },
+            );
           }
 
-          project.forceRegenerateSceneIds = project.forceRegenerateSceneIds.slice(0, forceRegenerateIndex).concat(project.forceRegenerateSceneIds.slice(forceRegenerateIndex + 1));
-          updatedProject = await this.projectRepository.updateProject(this.projectId, project);
-          await this.publishStateUpdate(updatedProject, "process_scene");
+          this.publishStateUpdate(project, "process_scene");
 
           console.log(`[${nodeName}]: Completed (Skipped)\n`);
           return {
             ...state,
-            project: updatedProject,
+            project,
             __interrupt__: undefined,
             __interrupt_resolved__: false,
           };
@@ -1162,7 +762,7 @@ export class CinematicVideoWorkflow {
 
         console.log(`[${nodeName}]: Processing scene ${scene.sceneIndex} (${index + 1}/${scenes.length}).`);
         const [ next ] = await this.assetManager.getNextVersionNumber({ projectId: this.projectId, sceneId: scene.id }, 'scene_video');
-        const result = await this.ensureJob(
+        await this.dispatcher.ensureJob(
           nodeName,
           "GENERATE_SCENE_VIDEO",
           "scene_video",
@@ -1170,41 +770,26 @@ export class CinematicVideoWorkflow {
             sceneId: scene.id,
             sceneIndex: scene.sceneIndex,
             version: next,
+            overridePrompt: shouldForceRegenerate,
           },
         );
-        const { scene: generatedScene, acceptedAttempt, evaluation, jobId } = result!;
-
-        // pretty sure these assets get creted on worker side...
-        await this.assetManager.createVersionedAssets(
-          { projectId: this.projectId, sceneId: scene.id },
-          'scene_video',
-          'video',
-          [ generatedScene.assets[ 'scene_video' ]?.versions[ acceptedAttempt ].data! ],
-          { model: videoModelName, evaluation, jobId },
-          true
-        );
 
-        await this.projectRepository.updateScenes([ generatedScene ]);
-        project = this.continuityAgent.updateNarrativeState(generatedScene, project);
-        if (evaluation) { project.generationRules = Array.from(new Set(...project.generationRules, ...extractGenerationRules([ evaluation ]))); }
-        project.forceRegenerateSceneIds = project.forceRegenerateSceneIds.slice(0, forceRegenerateIndex).concat(project.forceRegenerateSceneIds.slice(forceRegenerateIndex + 1));
-        updatedProject = await this.projectRepository.updateProject(this.projectId, project);
-        await this.publishStateUpdate(updatedProject, nodeName);
+        this.publishStateUpdate(project, nodeName);
 
         console.log(`[${nodeName}]: Completed\n`);
         return {
           ...state,
-          project: updatedProject,
+          project,
           currentSceneIndex: index + 1,
           __interrupt__: undefined,
           __interrupt_resolved__: false,
         };
       } else {
+        // Parallel execution
 
-        // Parallel logic (fan-out)
         const jobs: any[] = [];
-
         await Promise.all(scenes.map(async (scene) => {
+
           const forceRegenerateIndex = project?.forceRegenerateSceneIds.findIndex(id => id === scene.id);
           const shouldForceRegenerate = forceRegenerateIndex !== -1;
 
@@ -1212,10 +797,8 @@ export class CinematicVideoWorkflow {
           if (!shouldForceRegenerate) {
             const [ best ] = await this.assetManager.getBestVersion({ projectId: this.projectId, sceneId: scene.id }, 'scene_video');
             const videoUrl = best?.data;
-            if (videoUrl && await this.storageManager.fileExists(videoUrl)) {
-              videoExists = true;
-              console.log(`   ... Scene ${scene.id} video already exists, skipping.`);
-            }
+            videoExists = !!videoUrl && await this.storageManager.fileExists(videoUrl);
+            if (videoExists) console.log(`   ... Scene ${scene.id} video already exists, skipping.`);
           }
 
           if (shouldForceRegenerate || !videoExists) {
@@ -1227,6 +810,7 @@ export class CinematicVideoWorkflow {
                 sceneIndex: scene.sceneIndex,
                 sceneId: scene.id,
                 version: nextVersion,
+                overridePrompt: shouldForceRegenerate
               },
             });
           }
@@ -1234,73 +818,29 @@ export class CinematicVideoWorkflow {
 
         try {
           if (jobs.length > 0) {
-            const results = await this.ensureBatchJobs<"GENERATE_SCENE_VIDEO">(
+            await this.dispatcher.ensureBatchJobs<"GENERATE_SCENE_VIDEO">(
               nodeName,
               jobs,
             );
-
-            const generatedSceneIds: string[] = [];
-            for (const res of results) {
-              const { scene: generatedScene, evaluation, acceptedAttempt, jobId } = res;
-              await this.assetManager.createVersionedAssets(
-                { projectId: this.projectId, sceneId: generatedScene.id },
-                'scene_video',
-                'video',
-                [ generatedScene.assets[ 'scene_video' ]?.versions[ acceptedAttempt ].data! ],
-                {
-                  model: videoModelName,
-                  evaluation,
-                  jobId,
-                },
-                true
-              );
-              await this.projectRepository.updateScenes([ generatedScene ]);
-              generatedSceneIds.push(generatedScene.id);
-            }
-
-            // Update forceRegenerateSceneIds
-            if (generatedSceneIds.length > 0) {
-              const currentProject = await this.projectRepository.getProject(this.projectId);
-              const newForceList = currentProject.forceRegenerateSceneIds.filter(id => !generatedSceneIds.includes(id));
-
-              if (newForceList.length !== currentProject.forceRegenerateSceneIds.length) {
-                updatedProject = await this.projectRepository.updateProject(this.projectId, {
-                  forceRegenerateSceneIds: newForceList
-                });
-                console.log(`    Updated forceRegenerateSceneIds (removed ${generatedSceneIds.length} scenes)`);
-              }
-            }
           } else {
             console.log(`[${nodeName}]: All scenes skipped (already exist and not forced).`);
           }
 
-          updatedProject = await this.projectRepository.getProjectFullState(state.projectId);
-          await this.publishStateUpdate(project, nodeName);
+          this.publishStateUpdate(project, nodeName);
           console.log(`[${nodeName}]: Completed\n`);
           return {
             ...state,
-            project: updatedProject,
+            project,
             __interrupt__: undefined,
             __interrupt_resolved__: false,
           };
         } catch (error: any) {
-          if (error instanceof NodeInterrupt) {
-            throw error;
-          }
-
-          console.error(`[${nodeName}] error`, { error });
-          const currentAttempt = jobs.reduce((max, job) => Math.max(max, job.attempt || 0), 0);
-          return new Command({
-            goto: "error_handler",
-            update: {
-              nodeAttempts: { [ nodeName ]: currentAttempt },
-              errors: [ { node: nodeName, message: error?.message, value: error?.value, shouldRetry: true, timestamp: new Date().toISOString() } ]
-            }
-          });
+          const errorContext = JSON.parse(JSON.stringify(error?.message as string))?.[ 0 ]?.value || error?.message;
+          interceptNodeInterruptAndThrow(errorContext, nodeName, state.projectId, errorContext);
         }
       }
     }, {
-      ends: [ "process_scene", "render_video", "error_handler" ]
+      ends: [ "process_scene", "render_video", ]
     });
 
     workflow.addNode("render_video", async (state: WorkflowState) => {
@@ -1325,7 +865,7 @@ export class CinematicVideoWorkflow {
         }
 
         const [ version ] = await this.assetManager.getNextVersionNumber({ projectId: this.projectId }, 'render_video');
-        const result = await this.ensureJob(
+        const result = await this.dispatcher.ensureJob(
           nodeName,
           "RENDER_VIDEO",
           "render_video",
@@ -1351,21 +891,11 @@ export class CinematicVideoWorkflow {
           __interrupt_resolved__: false,
         };
       } catch (error: any) {
-        if (error instanceof NodeInterrupt) {
-          throw error;
-        }
-
-        console.error(`[${nodeName}] error`, { error });
-        return new Command({
-          goto: "error_handler",
-          update: {
-            nodeAttempts: { [ nodeName ]: currentAttempt },
-            errors: [ { node: nodeName, message: error?.message, value: error?.value, shouldRetry: true, timestamp: new Date().toISOString() } ]
-          }
-        });
+        const errorContext = JSON.parse(JSON.stringify(error?.message as string))?.[ 0 ]?.value || error?.message;
+        interceptNodeInterruptAndThrow(errorContext, nodeName, state.projectId, errorContext);
       }
     }, {
-      ends: [ "finalize", "error_handler" ]
+      ends: [ "finalize", ]
     });
 
     workflow.addNode("finalize", async (state: WorkflowState) => {
@@ -1385,7 +915,7 @@ export class CinematicVideoWorkflow {
       );
       console.log(`\n Video generation complete!`);
       console.log(`   Output saved to: ${this.storageManager.getPublicUrl(objectPath)}`);
-      await this.publishStateUpdate(project, "finalize");
+      this.publishStateUpdate(project, "finalize");
       console.log(`[${nodeName}]: Completed\n`);
       return {
         ...state,
@@ -1395,21 +925,21 @@ export class CinematicVideoWorkflow {
       };
     });
 
-    workflow.addNode("error_handler", errorHandler, {
-      ends: [
-        "expand_creative_prompt",
-        "generate_storyboard_exclusively_from_prompt",
-        "create_scenes_from_audio",
-        "enrich_storyboard_and_scenes",
-        "semantic_analysis",
-        "generate_character_assets",
-        "generate_location_assets",
-        "generate_scene_assets",
-        "process_scene",
-        "render_video",
-        "finalize"
-      ]
-    });
+    // workflow.addNode("error_handler", errorHandler, {
+    //   ends: [
+    //     "expand_creative_prompt",
+    //     "generate_storyboard_exclusively_from_prompt",
+    //     "create_scenes_from_audio",
+    //     "enrich_storyboard_and_scenes",
+    //     "semantic_analysis",
+    //     "generate_character_assets",
+    //     "generate_location_assets",
+    //     "generate_scene_assets",
+    //     "process_scene",
+    //     "render_video",
+    //     "finalize"
+    //   ]
+    // });
 
     return workflow;
   }
@@ -1535,7 +1065,28 @@ export class CinematicVideoWorkflow {
       }
     }
 
-    const compiled = this.graph.compile({ checkpointer });
+      const compiled = this.graph.compile({ checkpointer });
+
+      if (process.env.DEBUG === 'true' || process.env.NODE_ENV === 'development') {
+        const graphData = await compiled.getGraphAsync();
+
+        const mermaidText = graphData.drawMermaid();
+        const textPath = path.resolve('./docs/graph_structure.mmd');
+        await fs.writeFile(textPath, mermaidText);
+        console.debug(`[Debug]: Graph definition saved: file://${textPath}`);
+
+        try {
+          const pngBlob = await graphData.drawMermaidPng();
+          const pngBuffer = Buffer.from(await pngBlob.arrayBuffer());
+          const pngPath = path.resolve('./docs/graph_diagram.png');
+          await fs.writeFile(pngPath, pngBuffer);
+          console.debug(`[Debug]: Graph image saved: file://${pngPath}`);
+        } catch (e) {
+          console.warn("[Debug]: Failed to generate PNG. (Ensure 'canvas' or 'playwright' is available if required by your environment).");
+        }
+      }
+
+
     // INTERRUPTS ARE NOT HANDLED WHEN USING CLI EXECUTION!!
     result = await compiled.invoke(initialState, {
       configurable: { thread_id: this.projectId },
@@ -1625,7 +1176,7 @@ async function main() {
     console.debug(`Initialized topic ${JOB_EVENTS_TOPIC_NAME}`);
 
     const publishJobEvent = async (event: JobEvent) => {
-      console.log(`[Cinematic-Canvas] Publishing job event ${event.type} to ${JOB_EVENTS_TOPIC_NAME}`);
+      console.log(`[Cinematic-Canvas] Publishing job event ${event.type} to ${JOB_EVENTS_TOPIC_NAME}`, { event });
       const dataBuffer = Buffer.from(JSON.stringify(event));
       await jobEventsTopicPublisher.publishMessage({ data: dataBuffer });
     };
diff --git a/src/workflow/media-controller.ts b/src/workflow/media-controller.ts
index cee49f3..f48548c 100644
--- a/src/workflow/media-controller.ts
+++ b/src/workflow/media-controller.ts
@@ -131,8 +131,7 @@ export class MediaController {
     }
 
     getAudioDuration(filePath: string): Promise<number> {
-
-        return new Promise((resolve, reject) => {
+        const duration = new Promise((resolve, reject) => {
             this.ffprobe(filePath, (err: any, metadata: any) => {
                 if (err) {
                     reject(err);
@@ -141,7 +140,9 @@ export class MediaController {
                     resolve(duration || 0);
                 }
             });
-        });
+        }) as Promise<number>;
+        console.log(` Audio duration (ffprobe): ${duration}s`);
+        return duration;
     }
 
     private ffprobe(filePath: string, callback: (err: any, metadata: any) => void): void {
diff --git a/src/workflow/nodes/error-handler.ts b/src/workflow/nodes/error-handler.ts
index 3fcf82b..feb46c0 100644
--- a/src/workflow/nodes/error-handler.ts
+++ b/src/workflow/nodes/error-handler.ts
@@ -5,14 +5,13 @@ import { interceptNodeInterruptAndThrow } from "@shared/utils/errors";
 export const errorHandler = async (state: WorkflowState) => {
 
     const errorContext = state[ 'errors' ].at(-1);
-    console.debug(`Error context: `, JSON.stringify({ errorContext }));
-
-    if (state.__interrupt__?.length && !state.__interrupt_resolved__) {
+    console.debug(`[Error Handler Node] Error context: `, JSON.stringify({ errorContext }));
 
+    // if (state.__interrupt__?.length && !state.__interrupt_resolved__) {
         console.log(`[Error Handler Node]: Interrupt found. Surfacing unresolved error to user...`);
         interceptNodeInterruptAndThrow(errorContext, errorContext?.node || "Error Handler Node", state.projectId);
         return;
-    }
+    // }
 
     console.log(`[Error Handler Node]: No interrupt found. Retrying node: ${errorContext?.node}`);
     return new Command({
diff --git a/tsconfig.json b/tsconfig.json
index d090587..bc55602 100644
--- a/tsconfig.json
+++ b/tsconfig.json
@@ -1,11 +1,7 @@
 {
   "include": [
-    "src/client/src/**/*",
-    "src/shared/**/*",
-    "src/server/**/*",
-    "src/workflow/**/*",
-    "src/workflow/storage-manager.ts"
-, "src/client/tests/PlaybackControls.test.tsx", "src/client/tests/PlaybackControls_verification.test.tsx"  ],
+    "src/**/*",
+],
   "exclude": [
     "node_modules",
     "**/build",
@@ -36,12 +32,9 @@
       "vite/client"
     ],
     "paths": {
-      "@/*": [
-        "./src/client/src/*"
-      ],
-      "@shared/*": [
-        "./src/shared/*"
-      ]
+      "@/*": ["./src/client/src/*"],
+      "@shared/*": ["src/shared/*"],
+      "@shared/types/*": ["src/shared/types/*"]
     }
   }
 }
\ No newline at end of file
diff --git a/ui/project-select-modal-1.png b/ui/project-select-modal-1.png
new file mode 100644
index 0000000..ba1c627
Binary files /dev/null and b/ui/project-select-modal-1.png differ
diff --git a/ui/project-select-modal-2.png b/ui/project-select-modal-2.png
new file mode 100644
index 0000000..2e9b525
Binary files /dev/null and b/ui/project-select-modal-2.png differ
diff --git a/vite.config.node.ts b/vite.config.node.ts
index a6927a3..a9b517c 100644
--- a/vite.config.node.ts
+++ b/vite.config.node.ts
@@ -4,7 +4,6 @@ import path from 'path';
 export default defineConfig({
   resolve: {
     alias: {
-      "@": path.resolve(import.meta.dirname, "src", "client", "src"),
       "@shared": path.resolve(import.meta.dirname, "src", "shared"),
       "@assets": path.resolve(import.meta.dirname, "src", "attached_assets"),
     },
